{"ast":null,"code":"import { CallbackManager } from \"../callbacks/manager.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream } from \"../util/stream.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n  }\n  /**\n   * Bind arguments to a Runnable, returning a new Runnable.\n   * @param kwargs\n   * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n   */\n  bind(kwargs) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      kwargs\n    });\n  }\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(fields) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks({\n      runnable: this,\n      fallbacks: fields.fallbacks\n    });\n  }\n  _getOptionsList(options) {\n    let length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    if (Array.isArray(options)) {\n      if (options.length !== length) {\n        throw new Error(\"Passed \\\"options\\\" must be an array with the same length as the inputs, but got \".concat(options.length, \" options for \").concat(length, \" inputs\"));\n      }\n      return options;\n    }\n    return Array.from({\n      length\n    }, () => options);\n  }\n  /**\n   * Default implementation of batch, which calls invoke N times.\n   * Subclasses should override this method if they can batch more efficiently.\n   * @param inputs Array of inputs to each batch call.\n   * @param options Either a single call options object to apply to each batch call or an array for each call.\n   * @param batchOptions.maxConcurrency Maximum number of calls to run at once.\n   * @returns An array of RunOutputs\n   */\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);\n    const batchSize = batchOptions !== null && batchOptions !== void 0 && batchOptions.maxConcurrency && batchOptions.maxConcurrency > 0 ? batchOptions === null || batchOptions === void 0 ? void 0 : batchOptions.maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < inputs.length; i += batchSize) {\n      const batchPromises = inputs.slice(i, i + batchSize).map((input, j) => this.invoke(input, configList[j]));\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(input, options) {\n    yield this.invoke(input, options);\n  }\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(input, options) {\n    return IterableReadableStream.fromAsyncGenerator(this._streamIterator(input, options));\n  }\n  _separateRunnableConfigFromCallOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const runnableConfig = {\n      callbacks: options.callbacks,\n      tags: options.tags,\n      metadata: options.metadata\n    };\n    const callOptions = {\n      ...options\n    };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    return [runnableConfig, callOptions];\n  }\n  async _callWithConfig(func, input, options) {\n    const callbackManager_ = await CallbackManager.configure(options === null || options === void 0 ? void 0 : options.callbacks, undefined, options === null || options === void 0 ? void 0 : options.tags, undefined, options === null || options === void 0 ? void 0 : options.metadata);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, options === null || options === void 0 ? void 0 : options.runType));\n    let output;\n    try {\n      output = await func.bind(this)(input);\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(output, \"output\")));\n    return output;\n  }\n  async *_streamWithConfig(generator, options) {\n    const callbackManager_ = await CallbackManager.configure(options === null || options === void 0 ? void 0 : options.callbacks, undefined, options === null || options === void 0 ? void 0 : options.tags, undefined, options === null || options === void 0 ? void 0 : options.metadata);\n    // TODO: Find a way to pass the entire streamed value into the callback.\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(\"<streamed value>\", \"input\"), undefined, options === null || options === void 0 ? void 0 : options.runType));\n    let output;\n    let concatSupported = true;\n    try {\n      for await (const chunk of generator) {\n        yield chunk;\n        if (concatSupported) {\n          if (output === undefined) {\n            output = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              output = output.concat(chunk);\n            } catch (e) {\n              output = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(output, \"output\")));\n  }\n  _patchConfig() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let callbackManager = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    return {\n      ...config,\n      callbacks: callbackManager\n    };\n  }\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe(coerceable) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable)\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing) {\n    return thing.lc_runnable;\n  }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n */\nexport class RunnableSequence extends Runnable {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n  constructor(fields) {\n    var _fields$middle;\n    super(fields);\n    Object.defineProperty(this, \"first\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"middle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"last\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    this.first = fields.first;\n    this.middle = (_fields$middle = fields.middle) !== null && _fields$middle !== void 0 ? _fields$middle : this.middle;\n    this.last = fields.last;\n  }\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options === null || options === void 0 ? void 0 : options.callbacks, undefined, options === null || options === void 0 ? void 0 : options.tags, undefined, options === null || options === void 0 ? void 0 : options.metadata);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\")));\n    let nextStepInput = input;\n    let finalOutput;\n    try {\n      for (const step of [this.first, ...this.middle]) {\n        nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager === null || runManager === void 0 ? void 0 : runManager.getChild()));\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      finalOutput = await this.last.invoke(nextStepInput, this._patchConfig(options, runManager === null || runManager === void 0 ? void 0 : runManager.getChild()));\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, \"output\")));\n    return finalOutput;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => CallbackManager.configure(config === null || config === void 0 ? void 0 : config.callbacks, undefined, config === null || config === void 0 ? void 0 : config.tags, undefined, config === null || config === void 0 ? void 0 : config.metadata)));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager === null || callbackManager === void 0 ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs = inputs;\n    let finalOutputs;\n    try {\n      for (let i = 0; i < [this.first, ...this.middle].length; i += 1) {\n        const step = this.steps[i];\n        nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager === null || runManager === void 0 ? void 0 : runManager.getChild())), batchOptions);\n      }\n      finalOutputs = await this.last.batch(nextStepInputs, runManagers.map(runManager => this._patchConfig(configList[this.steps.length - 1], runManager === null || runManager === void 0 ? void 0 : runManager.getChild())), batchOptions);\n    } catch (e) {\n      await Promise.all(runManagers.map(runManager => runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e)));\n      throw e;\n    }\n    await Promise.all(runManagers.map((runManager, i) => runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutputs[i], \"output\"))));\n    return finalOutputs;\n  }\n  async *_streamIterator(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options === null || options === void 0 ? void 0 : options.callbacks, undefined, options === null || options === void 0 ? void 0 : options.tags, undefined, options === null || options === void 0 ? void 0 : options.metadata);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\")));\n    let nextStepInput = input;\n    const steps = [this.first, ...this.middle, this.last];\n    // Find the index of the last runnable in the sequence that doesn't have a .transform() method\n    // and start streaming from there\n    const streamingStartStepIndex = steps.length - [...steps].reverse().findIndex(step => typeof step.transform !== \"function\") - 1;\n    try {\n      for (const step of steps.slice(0, streamingStartStepIndex)) {\n        nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager === null || runManager === void 0 ? void 0 : runManager.getChild()));\n      }\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    let concatSupported = true;\n    let finalOutput;\n    try {\n      let finalGenerator = await steps[streamingStartStepIndex]._streamIterator(nextStepInput, this._patchConfig(options, runManager === null || runManager === void 0 ? void 0 : runManager.getChild()));\n      for (const step of steps.slice(streamingStartStepIndex + 1)) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        finalGenerator = await step.transform(finalGenerator, this._patchConfig(options, runManager === null || runManager === void 0 ? void 0 : runManager.getChild()));\n      }\n      for await (const chunk of finalGenerator) {\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = finalOutput.concat(chunk);\n            } catch (e) {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(finalOutput, \"output\")));\n  }\n  pipe(coerceable) {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([this.last, coerceable.first, ...coerceable.middle]),\n        last: coerceable.last\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable)\n      });\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing) {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n  static from(_ref) {\n    let [first, ...runnables] = _ref;\n    return new RunnableSequence({\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1])\n    });\n  }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n */\nexport class RunnableMap extends Runnable {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"steps\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n  async invoke(input, options\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const callbackManager_ = await CallbackManager.configure(options === null || options === void 0 ? void 0 : options.callbacks, undefined, options === null || options === void 0 ? void 0 : options.tags, undefined, options === null || options === void 0 ? void 0 : options.metadata);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), {\n      input\n    }));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output = {};\n    try {\n      for (const [key, runnable] of Object.entries(this.steps)) {\n        const result = await runnable.invoke(input, this._patchConfig(options, runManager === null || runManager === void 0 ? void 0 : runManager.getChild()));\n        output[key] = result;\n      }\n    } catch (e) {\n      await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(e));\n      throw e;\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(output));\n    return output;\n  }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.func = fields.func;\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(async input => this.func(input), input, options);\n  }\n}\n/**\n * A runnable that passes through the input.\n */\nexport class RunnablePassthrough extends Runnable {\n  constructor() {\n    super(...arguments);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n  }\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n  async invoke(input, options) {\n    return this._callWithConfig(input => Promise.resolve(input), input, options);\n  }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"bound\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"kwargs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n  }\n  bind(kwargs) {\n    return new RunnableBinding({\n      bound: this.bound,\n      kwargs: {\n        ...this.kwargs,\n        ...kwargs\n      }\n    });\n  }\n  async invoke(input, options) {\n    return this.bound.invoke(input, {\n      ...options,\n      ...this.kwargs\n    });\n  }\n  async batch(inputs, options, batchOptions) {\n    const mergedOptions = Array.isArray(options) ? options.map(individualOption => ({\n      ...individualOption,\n      ...this.kwargs\n    })) : {\n      ...options,\n      ...this.kwargs\n    };\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n  async stream(input, options) {\n    return this.bound.stream(input, {\n      ...options,\n      ...this.kwargs\n    });\n  }\n}\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n */\nexport class RouterRunnable extends Runnable {\n  static lc_name() {\n    return \"RouterRunnable\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnables\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnables = fields.runnables;\n  }\n  async invoke(input, options) {\n    const {\n      key,\n      input: actualInput\n    } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(\"No runnable associated with key \\\"\".concat(key, \"\\\".\"));\n    }\n    return runnable.invoke(actualInput, options);\n  }\n  async batch(inputs, options, batchOptions) {\n    const keys = inputs.map(input => input.key);\n    const actualInputs = inputs.map(input => input.input);\n    const missingKey = keys.find(key => this.runnables[key] === undefined);\n    if (missingKey !== undefined) {\n      throw new Error(\"One or more keys do not have a corresponding runnable.\");\n    }\n    const runnables = keys.map(key => this.runnables[key]);\n    const optionsList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);\n    const batchSize = batchOptions !== null && batchOptions !== void 0 && batchOptions.maxConcurrency && batchOptions.maxConcurrency > 0 ? batchOptions === null || batchOptions === void 0 ? void 0 : batchOptions.maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < actualInputs.length; i += batchSize) {\n      const batchPromises = actualInputs.slice(i, i + batchSize).map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n  async stream(input, options) {\n    const {\n      key,\n      input: actualInput\n    } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(\"No runnable associated with key \\\"\".concat(key, \"\\\".\"));\n    }\n    return runnable.stream(actualInput, options);\n  }\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"schema\", \"runnable\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fallbacks\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n  async invoke(input, options) {\n    const callbackManager_ = await CallbackManager.configure(options === null || options === void 0 ? void 0 : options.callbacks, undefined, options === null || options === void 0 ? void 0 : options.tags, undefined, options === null || options === void 0 ? void 0 : options.metadata);\n    const runManager = await (callbackManager_ === null || callbackManager_ === void 0 ? void 0 : callbackManager_.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\")));\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const output = await runnable.invoke(input, this._patchConfig(options, runManager === null || runManager === void 0 ? void 0 : runManager.getChild()));\n        await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(output, \"output\")));\n        return output;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (firstError === undefined) {\n      throw new Error(\"No error stored at end of fallback.\");\n    }\n    await (runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(firstError));\n    throw firstError;\n  }\n  async batch(inputs, options, batchOptions) {\n    const configList = this._getOptionsList(options !== null && options !== void 0 ? options : {}, inputs.length);\n    const callbackManagers = await Promise.all(configList.map(config => CallbackManager.configure(config === null || config === void 0 ? void 0 : config.callbacks, undefined, config === null || config === void 0 ? void 0 : config.tags, undefined, config === null || config === void 0 ? void 0 : config.metadata)));\n    const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager === null || callbackManager === void 0 ? void 0 : callbackManager.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError;\n    for (const runnable of this.runnables()) {\n      try {\n        const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager === null || runManager === void 0 ? void 0 : runManager.getChild())), batchOptions);\n        await Promise.all(runManagers.map((runManager, i) => runManager === null || runManager === void 0 ? void 0 : runManager.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(runManagers.map(runManager => runManager === null || runManager === void 0 ? void 0 : runManager.handleChainError(firstError)));\n    throw firstError;\n  }\n}\nfunction _coerceToRunnable(coerceable) {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({\n      func: coerceable\n    });\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value);\n    }\n    return new RunnableMap({\n      steps: runnables\n    });\n  } else {\n    throw new Error(\"Expected a Runnable, function or object.\\nInstead got an unsupported type.\");\n  }\n}","map":{"version":3,"names":["CallbackManager","Serializable","IterableReadableStream","_coerceToDict","value","defaultKey","Array","isArray","Runnable","constructor","arguments","Object","defineProperty","enumerable","configurable","writable","bind","kwargs","RunnableBinding","bound","withFallbacks","fields","RunnableWithFallbacks","runnable","fallbacks","_getOptionsList","options","length","undefined","Error","concat","from","batch","inputs","batchOptions","configList","batchSize","maxConcurrency","batchResults","i","batchPromises","slice","map","input","j","invoke","batchResult","Promise","all","push","flat","_streamIterator","stream","fromAsyncGenerator","_separateRunnableConfigFromCallOptions","runnableConfig","callbacks","tags","metadata","callOptions","_callWithConfig","func","callbackManager_","configure","runManager","handleChainStart","toJSON","runType","output","e","handleChainError","handleChainEnd","_streamWithConfig","generator","concatSupported","chunk","_patchConfig","config","callbackManager","pipe","coerceable","RunnableSequence","first","last","_coerceToRunnable","isRunnable","thing","lc_runnable","lc_name","_fields$middle","middle","steps","nextStepInput","finalOutput","step","getChild","callbackManagers","runManagers","nextStepInputs","finalOutputs","streamingStartStepIndex","reverse","findIndex","transform","finalGenerator","isRunnableSequence","_ref","runnables","RunnableMap","key","entries","result","RunnableLambda","RunnablePassthrough","resolve","mergedOptions","individualOption","RouterRunnable","actualInput","keys","actualInputs","missingKey","find","optionsList","fallback","firstError","outputs"],"sources":["C:/Users/zackb/OneDrive/Desktop/Bootcamp/best_project_ever/client/node_modules/langchain/dist/schema/runnable.js"],"sourcesContent":["import { CallbackManager } from \"../callbacks/manager.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport { IterableReadableStream } from \"../util/stream.js\";\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport class Runnable extends Serializable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    /**\n     * Bind arguments to a Runnable, returning a new Runnable.\n     * @param kwargs\n     * @returns A new RunnableBinding that, when invoked, will apply the bound args.\n     */\n    bind(kwargs) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableBinding({ bound: this, kwargs });\n    }\n    /**\n     * Create a new runnable from the current one that will try invoking\n     * other passed fallback runnables if the initial invocation fails.\n     * @param fields.fallbacks Other runnables to call if the runnable errors.\n     * @returns A new RunnableWithFallbacks.\n     */\n    withFallbacks(fields) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableWithFallbacks({\n            runnable: this,\n            fallbacks: fields.fallbacks,\n        });\n    }\n    _getOptionsList(options, length = 0) {\n        if (Array.isArray(options)) {\n            if (options.length !== length) {\n                throw new Error(`Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`);\n            }\n            return options;\n        }\n        return Array.from({ length }, () => options);\n    }\n    /**\n     * Default implementation of batch, which calls invoke N times.\n     * Subclasses should override this method if they can batch more efficiently.\n     * @param inputs Array of inputs to each batch call.\n     * @param options Either a single call options object to apply to each batch call or an array for each call.\n     * @param batchOptions.maxConcurrency Maximum number of calls to run at once.\n     * @returns An array of RunOutputs\n     */\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const batchSize = batchOptions?.maxConcurrency && batchOptions.maxConcurrency > 0\n            ? batchOptions?.maxConcurrency\n            : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < inputs.length; i += batchSize) {\n            const batchPromises = inputs\n                .slice(i, i + batchSize)\n                .map((input, j) => this.invoke(input, configList[j]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    /**\n     * Default streaming implementation.\n     * Subclasses should override this method if they support streaming output.\n     * @param input\n     * @param options\n     */\n    async *_streamIterator(input, options) {\n        yield this.invoke(input, options);\n    }\n    /**\n     * Stream output in chunks.\n     * @param input\n     * @param options\n     * @returns A readable stream that is also an iterable.\n     */\n    async stream(input, options) {\n        return IterableReadableStream.fromAsyncGenerator(this._streamIterator(input, options));\n    }\n    _separateRunnableConfigFromCallOptions(options = {}) {\n        const runnableConfig = {\n            callbacks: options.callbacks,\n            tags: options.tags,\n            metadata: options.metadata,\n        };\n        const callOptions = { ...options };\n        delete callOptions.callbacks;\n        delete callOptions.tags;\n        delete callOptions.metadata;\n        return [runnableConfig, callOptions];\n    }\n    async _callWithConfig(func, input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), undefined, options?.runType);\n        let output;\n        try {\n            output = await func.bind(this)(input);\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n        return output;\n    }\n    async *_streamWithConfig(generator, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        // TODO: Find a way to pass the entire streamed value into the callback.\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(\"<streamed value>\", \"input\"), undefined, options?.runType);\n        let output;\n        let concatSupported = true;\n        try {\n            for await (const chunk of generator) {\n                yield chunk;\n                if (concatSupported) {\n                    if (output === undefined) {\n                        output = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            output = output.concat(chunk);\n                        }\n                        catch (e) {\n                            output = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    }\n    _patchConfig(config = {}, callbackManager = undefined) {\n        return { ...config, callbacks: callbackManager };\n    }\n    /**\n     * Create a new runnable sequence that runs each individual runnable in series,\n     * piping the output of one runnable into another runnable or runnable-like.\n     * @param coerceable A runnable, function, or object whose values are functions or runnables.\n     * @returns A new runnable sequence.\n     */\n    pipe(coerceable) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunnableSequence({\n            first: this,\n            last: _coerceToRunnable(coerceable),\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnable(thing) {\n        return thing.lc_runnable;\n    }\n}\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n */\nexport class RunnableSequence extends Runnable {\n    static lc_name() {\n        return \"RunnableSequence\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"first\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"middle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"last\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        this.first = fields.first;\n        this.middle = fields.middle ?? this.middle;\n        this.last = fields.last;\n    }\n    get steps() {\n        return [this.first, ...this.middle, this.last];\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n        let nextStepInput = input;\n        let finalOutput;\n        try {\n            for (const step of [this.first, ...this.middle]) {\n                nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n            }\n            // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n            finalOutput = await this.last.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n        return finalOutput;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let nextStepInputs = inputs;\n        let finalOutputs;\n        try {\n            for (let i = 0; i < [this.first, ...this.middle].length; i += 1) {\n                const step = this.steps[i];\n                nextStepInputs = await step.batch(nextStepInputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager?.getChild())), batchOptions);\n            }\n            finalOutputs = await this.last.batch(nextStepInputs, runManagers.map((runManager) => this._patchConfig(configList[this.steps.length - 1], runManager?.getChild())), batchOptions);\n        }\n        catch (e) {\n            await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(e)));\n            throw e;\n        }\n        await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(finalOutputs[i], \"output\"))));\n        return finalOutputs;\n    }\n    async *_streamIterator(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n        let nextStepInput = input;\n        const steps = [this.first, ...this.middle, this.last];\n        // Find the index of the last runnable in the sequence that doesn't have a .transform() method\n        // and start streaming from there\n        const streamingStartStepIndex = steps.length -\n            [...steps]\n                .reverse()\n                .findIndex((step) => typeof step.transform !== \"function\") -\n            1;\n        try {\n            for (const step of steps.slice(0, streamingStartStepIndex)) {\n                nextStepInput = await step.invoke(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        let concatSupported = true;\n        let finalOutput;\n        try {\n            let finalGenerator = await steps[streamingStartStepIndex]._streamIterator(nextStepInput, this._patchConfig(options, runManager?.getChild()));\n            for (const step of steps.slice(streamingStartStepIndex + 1)) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                finalGenerator = await step.transform(finalGenerator, this._patchConfig(options, runManager?.getChild()));\n            }\n            for await (const chunk of finalGenerator) {\n                yield chunk;\n                if (concatSupported) {\n                    if (finalOutput === undefined) {\n                        finalOutput = chunk;\n                    }\n                    else {\n                        try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            finalOutput = finalOutput.concat(chunk);\n                        }\n                        catch (e) {\n                            finalOutput = undefined;\n                            concatSupported = false;\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    }\n    pipe(coerceable) {\n        if (RunnableSequence.isRunnableSequence(coerceable)) {\n            return new RunnableSequence({\n                first: this.first,\n                middle: this.middle.concat([\n                    this.last,\n                    coerceable.first,\n                    ...coerceable.middle,\n                ]),\n                last: coerceable.last,\n            });\n        }\n        else {\n            return new RunnableSequence({\n                first: this.first,\n                middle: [...this.middle, this.last],\n                last: _coerceToRunnable(coerceable),\n            });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static isRunnableSequence(thing) {\n        return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n    }\n    static from([first, ...runnables]) {\n        return new RunnableSequence({\n            first: _coerceToRunnable(first),\n            middle: runnables.slice(0, -1).map(_coerceToRunnable),\n            last: _coerceToRunnable(runnables[runnables.length - 1]),\n        });\n    }\n}\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n */\nexport class RunnableMap extends Runnable {\n    static lc_name() {\n        return \"RunnableMap\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"steps\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.steps = {};\n        for (const [key, value] of Object.entries(fields.steps)) {\n            this.steps[key] = _coerceToRunnable(value);\n        }\n    }\n    async invoke(input, options\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), {\n            input,\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const output = {};\n        try {\n            for (const [key, runnable] of Object.entries(this.steps)) {\n                const result = await runnable.invoke(input, this._patchConfig(options, runManager?.getChild()));\n                output[key] = result;\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(output);\n        return output;\n    }\n}\n/**\n * A runnable that runs a callable.\n */\nexport class RunnableLambda extends Runnable {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.func = fields.func;\n    }\n    async invoke(input, options) {\n        return this._callWithConfig(async (input) => this.func(input), input, options);\n    }\n}\n/**\n * A runnable that passes through the input.\n */\nexport class RunnablePassthrough extends Runnable {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"RunnablePassthrough\";\n    }\n    async invoke(input, options) {\n        return this._callWithConfig((input) => Promise.resolve(input), input, options);\n    }\n}\n/**\n * A runnable that delegates calls to another runnable with a set of kwargs.\n */\nexport class RunnableBinding extends Runnable {\n    static lc_name() {\n        return \"RunnableBinding\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"bound\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"kwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.bound = fields.bound;\n        this.kwargs = fields.kwargs;\n    }\n    bind(kwargs) {\n        return new RunnableBinding({\n            bound: this.bound,\n            kwargs: { ...this.kwargs, ...kwargs },\n        });\n    }\n    async invoke(input, options) {\n        return this.bound.invoke(input, { ...options, ...this.kwargs });\n    }\n    async batch(inputs, options, batchOptions) {\n        const mergedOptions = Array.isArray(options)\n            ? options.map((individualOption) => ({\n                ...individualOption,\n                ...this.kwargs,\n            }))\n            : { ...options, ...this.kwargs };\n        return this.bound.batch(inputs, mergedOptions, batchOptions);\n    }\n    async stream(input, options) {\n        return this.bound.stream(input, { ...options, ...this.kwargs });\n    }\n}\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n */\nexport class RouterRunnable extends Runnable {\n    static lc_name() {\n        return \"RouterRunnable\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnables = fields.runnables;\n    }\n    async invoke(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.invoke(actualInput, options);\n    }\n    async batch(inputs, options, batchOptions) {\n        const keys = inputs.map((input) => input.key);\n        const actualInputs = inputs.map((input) => input.input);\n        const missingKey = keys.find((key) => this.runnables[key] === undefined);\n        if (missingKey !== undefined) {\n            throw new Error(`One or more keys do not have a corresponding runnable.`);\n        }\n        const runnables = keys.map((key) => this.runnables[key]);\n        const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n        const batchSize = batchOptions?.maxConcurrency && batchOptions.maxConcurrency > 0\n            ? batchOptions?.maxConcurrency\n            : inputs.length;\n        const batchResults = [];\n        for (let i = 0; i < actualInputs.length; i += batchSize) {\n            const batchPromises = actualInputs\n                .slice(i, i + batchSize)\n                .map((actualInput, i) => runnables[i].invoke(actualInput, optionsList[i]));\n            const batchResult = await Promise.all(batchPromises);\n            batchResults.push(batchResult);\n        }\n        return batchResults.flat();\n    }\n    async stream(input, options) {\n        const { key, input: actualInput } = input;\n        const runnable = this.runnables[key];\n        if (runnable === undefined) {\n            throw new Error(`No runnable associated with key \"${key}\".`);\n        }\n        return runnable.stream(actualInput, options);\n    }\n}\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n */\nexport class RunnableWithFallbacks extends Runnable {\n    static lc_name() {\n        return \"RunnableWithFallbacks\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"schema\", \"runnable\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fallbacks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.fallbacks = fields.fallbacks;\n    }\n    *runnables() {\n        yield this.runnable;\n        for (const fallback of this.fallbacks) {\n            yield fallback;\n        }\n    }\n    async invoke(input, options) {\n        const callbackManager_ = await CallbackManager.configure(options?.callbacks, undefined, options?.tags, undefined, options?.metadata);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"));\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const output = await runnable.invoke(input, this._patchConfig(options, runManager?.getChild()));\n                await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n                return output;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (firstError === undefined) {\n            throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n    }\n    async batch(inputs, options, batchOptions) {\n        const configList = this._getOptionsList(options ?? {}, inputs.length);\n        const callbackManagers = await Promise.all(configList.map((config) => CallbackManager.configure(config?.callbacks, undefined, config?.tags, undefined, config?.metadata)));\n        const runManagers = await Promise.all(callbackManagers.map((callbackManager, i) => callbackManager?.handleChainStart(this.toJSON(), _coerceToDict(inputs[i], \"input\"))));\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let firstError;\n        for (const runnable of this.runnables()) {\n            try {\n                const outputs = await runnable.batch(inputs, runManagers.map((runManager, j) => this._patchConfig(configList[j], runManager?.getChild())), batchOptions);\n                await Promise.all(runManagers.map((runManager, i) => runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))));\n                return outputs;\n            }\n            catch (e) {\n                if (firstError === undefined) {\n                    firstError = e;\n                }\n            }\n        }\n        if (!firstError) {\n            throw new Error(\"No error stored at end of fallbacks.\");\n        }\n        await Promise.all(runManagers.map((runManager) => runManager?.handleChainError(firstError)));\n        throw firstError;\n    }\n}\nfunction _coerceToRunnable(coerceable) {\n    if (typeof coerceable === \"function\") {\n        return new RunnableLambda({ func: coerceable });\n    }\n    else if (Runnable.isRunnable(coerceable)) {\n        return coerceable;\n    }\n    else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n        const runnables = {};\n        for (const [key, value] of Object.entries(coerceable)) {\n            runnables[key] = _coerceToRunnable(value);\n        }\n        return new RunnableMap({ steps: runnables });\n    }\n    else {\n        throw new Error(`Expected a Runnable, function or object.\\nInstead got an unsupported type.`);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}