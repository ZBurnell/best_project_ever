{"ast":null,"code":"import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n  const runtimeEnv = await getRuntimeEnvironment();\n  const envVars = getLangChainEnvVarsMetadata();\n  return runs.map(run => {\n    var _run$extra, _run$revision_id;\n    const extra = (_run$extra = run.extra) !== null && _run$extra !== void 0 ? _run$extra : {};\n    const metadata = extra.metadata;\n    run.extra = {\n      ...extra,\n      runtime: {\n        ...runtimeEnv,\n        ...(extra === null || extra === void 0 ? void 0 : extra.runtime)\n      },\n      metadata: {\n        ...envVars,\n        ...(envVars.revision_id || run.revision_id ? {\n          revision_id: (_run$revision_id = run.revision_id) !== null && _run$revision_id !== void 0 ? _run$revision_id : envVars.revision_id\n        } : {}),\n        ...metadata\n      }\n    };\n    return run;\n  });\n}\nconst getTracingSamplingRate = () => {\n  const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n  if (samplingRateStr === undefined) {\n    return undefined;\n  }\n  const samplingRate = parseFloat(samplingRateStr);\n  if (samplingRate < 0 || samplingRate > 1) {\n    throw new Error(\"LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: \".concat(samplingRate));\n  }\n  return samplingRate;\n};\n// utility functions\nconst isLocalhost = url => {\n  const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n  const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n  return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation) => {\n  // consume the response body to release the connection\n  // https://undici.nodejs.org/#/?id=garbage-collection\n  const body = await response.text();\n  if (!response.ok) {\n    throw new Error(\"Failed to \".concat(operation, \": \").concat(response.status, \" \").concat(response.statusText, \" \").concat(body));\n  }\n};\nasync function toArray(iterable) {\n  const result = [];\n  for await (const item of iterable) {\n    result.push(item);\n  }\n  return result;\n}\nfunction trimQuotes(str) {\n  if (str === undefined) {\n    return undefined;\n  }\n  return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n  if (!uuid.validate(str)) {\n    throw new Error(\"Invalid UUID: \".concat(str));\n  }\n}\nexport class Client {\n  constructor() {\n    var _trimQuotes, _config$apiUrl, _config$apiKey, _config$webUrl, _config$timeout_ms, _config$callerOptions, _config$hideInputs, _config$hideOutputs, _config$autoBatchTrac, _config$pendingAutoBa;\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Object.defineProperty(this, \"apiKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"apiUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"webUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"caller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"timeout_ms\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tenantId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"hideInputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"hideOutputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tracingSampleRate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"sampledPostUuids\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, \"autoBatchTracing\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"pendingAutoBatchedRuns\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 100\n    });\n    Object.defineProperty(this, \"autoBatchTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 250\n    });\n    Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 50\n    });\n    const defaultConfig = Client.getDefaultClientConfig();\n    this.tracingSampleRate = getTracingSamplingRate();\n    this.apiUrl = (_trimQuotes = trimQuotes((_config$apiUrl = config.apiUrl) !== null && _config$apiUrl !== void 0 ? _config$apiUrl : defaultConfig.apiUrl)) !== null && _trimQuotes !== void 0 ? _trimQuotes : \"\";\n    this.apiKey = trimQuotes((_config$apiKey = config.apiKey) !== null && _config$apiKey !== void 0 ? _config$apiKey : defaultConfig.apiKey);\n    this.webUrl = trimQuotes((_config$webUrl = config.webUrl) !== null && _config$webUrl !== void 0 ? _config$webUrl : defaultConfig.webUrl);\n    this.validateApiKeyIfHosted();\n    this.timeout_ms = (_config$timeout_ms = config.timeout_ms) !== null && _config$timeout_ms !== void 0 ? _config$timeout_ms : 12000;\n    this.caller = new AsyncCaller((_config$callerOptions = config.callerOptions) !== null && _config$callerOptions !== void 0 ? _config$callerOptions : {});\n    this.hideInputs = (_config$hideInputs = config.hideInputs) !== null && _config$hideInputs !== void 0 ? _config$hideInputs : defaultConfig.hideInputs;\n    this.hideOutputs = (_config$hideOutputs = config.hideOutputs) !== null && _config$hideOutputs !== void 0 ? _config$hideOutputs : defaultConfig.hideOutputs;\n    this.autoBatchTracing = (_config$autoBatchTrac = config.autoBatchTracing) !== null && _config$autoBatchTrac !== void 0 ? _config$autoBatchTrac : this.autoBatchTracing;\n    this.pendingAutoBatchedRunLimit = (_config$pendingAutoBa = config.pendingAutoBatchedRunLimit) !== null && _config$pendingAutoBa !== void 0 ? _config$pendingAutoBa : this.pendingAutoBatchedRunLimit;\n  }\n  static getDefaultClientConfig() {\n    var _getEnvironmentVariab;\n    const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n    const apiUrl = (_getEnvironmentVariab = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\")) !== null && _getEnvironmentVariab !== void 0 ? _getEnvironmentVariab : \"https://api.smith.langchain.com\";\n    const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n    const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n    return {\n      apiUrl: apiUrl,\n      apiKey: apiKey,\n      webUrl: undefined,\n      hideInputs: hideInputs,\n      hideOutputs: hideOutputs\n    };\n  }\n  validateApiKeyIfHosted() {\n    const isLocal = isLocalhost(this.apiUrl);\n    if (!isLocal && !this.apiKey) {\n      throw new Error(\"API key must be provided when using hosted LangSmith API\");\n    }\n  }\n  getHostUrl() {\n    if (this.webUrl) {\n      return this.webUrl;\n    } else if (isLocalhost(this.apiUrl)) {\n      this.webUrl = \"http://localhost\";\n      return \"http://localhost\";\n    } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n      this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n      return this.webUrl;\n    } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n      this.webUrl = \"https://dev.smith.langchain.com\";\n      return \"https://dev.smith.langchain.com\";\n    } else {\n      this.webUrl = \"https://smith.langchain.com\";\n      return \"https://smith.langchain.com\";\n    }\n  }\n  get headers() {\n    const headers = {\n      \"User-Agent\": \"langsmith-js/\".concat(__version__)\n    };\n    if (this.apiKey) {\n      headers[\"x-api-key\"] = \"\".concat(this.apiKey);\n    }\n    return headers;\n  }\n  processInputs(inputs) {\n    if (this.hideInputs) {\n      return {};\n    }\n    return inputs;\n  }\n  processOutputs(outputs) {\n    if (this.hideOutputs) {\n      return {};\n    }\n    return outputs;\n  }\n  prepareRunCreateOrUpdateInputs(run) {\n    const runParams = {\n      ...run\n    };\n    if (runParams.inputs !== undefined) {\n      runParams.inputs = this.processInputs(runParams.inputs);\n    }\n    if (runParams.outputs !== undefined) {\n      runParams.outputs = this.processOutputs(runParams.outputs);\n    }\n    return runParams;\n  }\n  async _getResponse(path, queryParams) {\n    var _queryParams$toString;\n    const paramsString = (_queryParams$toString = queryParams === null || queryParams === void 0 ? void 0 : queryParams.toString()) !== null && _queryParams$toString !== void 0 ? _queryParams$toString : \"\";\n    const url = \"\".concat(this.apiUrl).concat(path, \"?\").concat(paramsString);\n    const response = await this.caller.call(fetch, url, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to fetch \".concat(path, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    return response;\n  }\n  async _get(path, queryParams) {\n    const response = await this._getResponse(path, queryParams);\n    return response.json();\n  }\n  _getPaginated(path) {\n    try {\n      var _this = this;\n      let queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new URLSearchParams();\n      return async function* () {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n          queryParams.set(\"offset\", String(offset));\n          queryParams.set(\"limit\", String(limit));\n          const url = \"\".concat(_this.apiUrl).concat(path, \"?\").concat(queryParams);\n          const response = await _this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: _this.headers,\n            signal: AbortSignal.timeout(_this.timeout_ms)\n          });\n          if (!response.ok) {\n            throw new Error(\"Failed to fetch \".concat(path, \": \").concat(response.status, \" \").concat(response.statusText));\n          }\n          const items = await response.json();\n          if (items.length === 0) {\n            break;\n          }\n          yield items;\n          if (items.length < limit) {\n            break;\n          }\n          offset += items.length;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  _getCursorPaginatedList(path) {\n    try {\n      var _this2 = this;\n      let body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      let requestMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"POST\";\n      let dataKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"runs\";\n      return async function* () {\n        const bodyParams = body ? {\n          ...body\n        } : {};\n        while (true) {\n          const response = await _this2.caller.call(fetch, \"\".concat(_this2.apiUrl).concat(path), {\n            method: requestMethod,\n            headers: {\n              ..._this2.headers,\n              \"Content-Type\": \"application/json\"\n            },\n            signal: AbortSignal.timeout(_this2.timeout_ms),\n            body: JSON.stringify(bodyParams)\n          });\n          const responseBody = await response.json();\n          if (!responseBody) {\n            break;\n          }\n          if (!responseBody[dataKey]) {\n            break;\n          }\n          yield responseBody[dataKey];\n          const cursors = responseBody.cursors;\n          if (!cursors) {\n            break;\n          }\n          if (!cursors.next) {\n            break;\n          }\n          bodyParams.cursor = cursors.next;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  _filterForSampling(runs) {\n    let patch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.tracingSampleRate === undefined) {\n      return runs;\n    }\n    if (patch) {\n      const sampled = [];\n      for (const run of runs) {\n        if (this.sampledPostUuids.has(run.id)) {\n          sampled.push(run);\n          this.sampledPostUuids.delete(run.id);\n        }\n      }\n      return sampled;\n    } else {\n      const sampled = [];\n      for (const run of runs) {\n        if (Math.random() < this.tracingSampleRate) {\n          sampled.push(run);\n          this.sampledPostUuids.add(run.id);\n        }\n      }\n      return sampled;\n    }\n  }\n  async triggerAutoBatchSend(runs) {\n    let batch = runs;\n    if (batch === undefined) {\n      batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n      this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n    }\n    await this.batchIngestRuns({\n      runCreates: batch.filter(item => item.action === \"create\").map(item => item.item),\n      runUpdates: batch.filter(item => item.action === \"update\").map(item => item.item)\n    });\n  }\n  appendRunCreateToAutoBatchQueue(item) {\n    const oldTimeout = this.autoBatchTimeout;\n    clearTimeout(this.autoBatchTimeout);\n    this.autoBatchTimeout = undefined;\n    this.pendingAutoBatchedRuns.push(item);\n    while (this.pendingAutoBatchedRuns.length >= this.pendingAutoBatchedRunLimit) {\n      const batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n      this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n      void this.triggerAutoBatchSend(batch);\n    }\n    if (this.pendingAutoBatchedRuns.length > 0) {\n      if (!oldTimeout) {\n        this.autoBatchTimeout = setTimeout(() => {\n          this.autoBatchTimeout = undefined;\n          void this.triggerAutoBatchSend();\n        }, this.autoBatchInitialDelayMs);\n      } else {\n        this.autoBatchTimeout = setTimeout(() => {\n          this.autoBatchTimeout = undefined;\n          void this.triggerAutoBatchSend();\n        }, this.autoBatchAggregationDelayMs);\n      }\n    }\n  }\n  async createRun(run) {\n    var _run$start_time;\n    if (!this._filterForSampling([run]).length) {\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const session_name = run.project_name;\n    delete run.project_name;\n    const runCreate = this.prepareRunCreateOrUpdateInputs({\n      session_name,\n      ...run,\n      start_time: (_run$start_time = run.start_time) !== null && _run$start_time !== void 0 ? _run$start_time : Date.now()\n    });\n    if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n      this.appendRunCreateToAutoBatchQueue({\n        action: \"create\",\n        item: runCreate\n      });\n      return;\n    }\n    const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([runCreate]);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs\"), {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(mergedRunCreateParams[0]),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create run\");\n  }\n  /**\n   * Batch ingest/upsert multiple runs in the Langsmith system.\n   * @param runs\n   */\n  async batchIngestRuns(_ref) {\n    var _runCreates$map, _runUpdates$map;\n    let {\n      runCreates,\n      runUpdates\n    } = _ref;\n    if (runCreates === undefined && runUpdates === undefined) {\n      return;\n    }\n    let preparedCreateParams = (_runCreates$map = runCreates === null || runCreates === void 0 ? void 0 : runCreates.map(create => this.prepareRunCreateOrUpdateInputs(create))) !== null && _runCreates$map !== void 0 ? _runCreates$map : [];\n    let preparedUpdateParams = (_runUpdates$map = runUpdates === null || runUpdates === void 0 ? void 0 : runUpdates.map(update => this.prepareRunCreateOrUpdateInputs(update))) !== null && _runUpdates$map !== void 0 ? _runUpdates$map : [];\n    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n      const createById = preparedCreateParams.reduce((params, run) => {\n        if (!run.id) {\n          return params;\n        }\n        params[run.id] = run;\n        return params;\n      }, {});\n      const standaloneUpdates = [];\n      for (const updateParam of preparedUpdateParams) {\n        if (updateParam.id !== undefined && createById[updateParam.id]) {\n          createById[updateParam.id] = {\n            ...createById[updateParam.id],\n            ...updateParam\n          };\n        } else {\n          standaloneUpdates.push(updateParam);\n        }\n      }\n      preparedCreateParams = Object.values(createById);\n      preparedUpdateParams = standaloneUpdates;\n    }\n    const body = {\n      post: this._filterForSampling(preparedCreateParams),\n      patch: this._filterForSampling(preparedUpdateParams, true)\n    };\n    if (!body.post.length && !body.patch.length) {\n      return;\n    }\n    preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\"\n    };\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs/batch\"), {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"batch create run\");\n  }\n  async updateRun(runId, run) {\n    assertUuid(runId);\n    if (run.inputs) {\n      run.inputs = this.processInputs(run.inputs);\n    }\n    if (run.outputs) {\n      run.outputs = this.processOutputs(run.outputs);\n    }\n    // TODO: Untangle types\n    const data = {\n      ...run,\n      id: runId\n    };\n    if (!this._filterForSampling([data], true).length) {\n      return;\n    }\n    if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n      this.appendRunCreateToAutoBatchQueue({\n        action: \"update\",\n        item: data\n      });\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs/\").concat(runId), {\n      method: \"PATCH\",\n      headers,\n      body: JSON.stringify(run),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update run\");\n  }\n  async readRun(runId) {\n    let {\n      loadChildRuns\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      loadChildRuns: false\n    };\n    assertUuid(runId);\n    let run = await this._get(\"/runs/\".concat(runId));\n    if (loadChildRuns && run.child_run_ids) {\n      run = await this._loadChildRuns(run);\n    }\n    return run;\n  }\n  async getRunUrl(_ref2) {\n    let {\n      runId,\n      run,\n      projectOpts\n    } = _ref2;\n    if (run !== undefined) {\n      let sessionId;\n      if (run.session_id) {\n        sessionId = run.session_id;\n      } else if (projectOpts !== null && projectOpts !== void 0 && projectOpts.projectName) {\n        sessionId = (await this.readProject({\n          projectName: projectOpts === null || projectOpts === void 0 ? void 0 : projectOpts.projectName\n        })).id;\n      } else if (projectOpts !== null && projectOpts !== void 0 && projectOpts.projectId) {\n        sessionId = projectOpts === null || projectOpts === void 0 ? void 0 : projectOpts.projectId;\n      } else {\n        const project = await this.readProject({\n          projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\"\n        });\n        sessionId = project.id;\n      }\n      const tenantId = await this._getTenantId();\n      return \"\".concat(this.getHostUrl(), \"/o/\").concat(tenantId, \"/projects/p/\").concat(sessionId, \"/r/\").concat(run.id, \"?poll=true\");\n    } else if (runId !== undefined) {\n      const run_ = await this.readRun(runId);\n      if (!run_.app_path) {\n        throw new Error(\"Run \".concat(runId, \" has no app_path\"));\n      }\n      const baseUrl = this.getHostUrl();\n      return \"\".concat(baseUrl).concat(run_.app_path);\n    } else {\n      throw new Error(\"Must provide either runId or run\");\n    }\n  }\n  async _loadChildRuns(run) {\n    const childRuns = await toArray(this.listRuns({\n      id: run.child_run_ids\n    }));\n    const treemap = {};\n    const runs = {};\n    // TODO: make dotted order required when the migration finishes\n    childRuns.sort((a, b) => {\n      var _a$dotted_order, _b$dotted_order;\n      return ((_a$dotted_order = a === null || a === void 0 ? void 0 : a.dotted_order) !== null && _a$dotted_order !== void 0 ? _a$dotted_order : \"\").localeCompare((_b$dotted_order = b === null || b === void 0 ? void 0 : b.dotted_order) !== null && _b$dotted_order !== void 0 ? _b$dotted_order : \"\");\n    });\n    for (const childRun of childRuns) {\n      if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n        throw new Error(\"Child run \".concat(childRun.id, \" has no parent\"));\n      }\n      if (!(childRun.parent_run_id in treemap)) {\n        treemap[childRun.parent_run_id] = [];\n      }\n      treemap[childRun.parent_run_id].push(childRun);\n      runs[childRun.id] = childRun;\n    }\n    run.child_runs = treemap[run.id] || [];\n    for (const runId in treemap) {\n      if (runId !== run.id) {\n        runs[runId].child_runs = treemap[runId];\n      }\n    }\n    return run;\n  }\n  listRuns(_ref3) {\n    try {\n      var _this3 = this;\n      let {\n        projectId,\n        projectName,\n        parentRunId,\n        referenceExampleId,\n        startTime,\n        executionOrder,\n        runType,\n        error,\n        id,\n        query,\n        filter,\n        limit\n      } = _ref3;\n      return async function* () {\n        let projectId_ = projectId;\n        if (projectName) {\n          if (projectId) {\n            throw new Error(\"Only one of projectId or projectName may be given\");\n          }\n          projectId_ = (await _this3.readProject({\n            projectName\n          })).id;\n        }\n        const body = {\n          session: projectId_ ? [projectId_] : null,\n          run_type: runType,\n          reference_example: referenceExampleId,\n          query,\n          filter,\n          execution_order: executionOrder,\n          parent_run: parentRunId ? [parentRunId] : null,\n          start_time: startTime ? startTime.toISOString() : null,\n          error,\n          id,\n          limit\n        };\n        for await (const runs of _this3._getCursorPaginatedList(\"/runs/query\", body)) {\n          yield* runs;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  async shareRun(runId) {\n    let {\n      shareId\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const data = {\n      run_id: runId,\n      share_token: shareId || uuid.v4()\n    };\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs/\").concat(runId, \"/share\"), {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      throw new Error(\"Invalid response from server\");\n    }\n    return \"\".concat(this.getHostUrl(), \"/public/\").concat(result[\"share_token\"], \"/r\");\n  }\n  async unshareRun(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs/\").concat(runId, \"/share\"), {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare run\");\n  }\n  async readRunSharedLink(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/runs/\").concat(runId, \"/share\"), {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      return undefined;\n    }\n    return \"\".concat(this.getHostUrl(), \"/public/\").concat(result[\"share_token\"], \"/r\");\n  }\n  async listSharedRuns(shareToken) {\n    let {\n      runIds\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const queryParams = new URLSearchParams({\n      share_token: shareToken\n    });\n    if (runIds !== undefined) {\n      for (const runId of runIds) {\n        queryParams.append(\"id\", runId);\n      }\n    }\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/public/\").concat(shareToken, \"/runs\").concat(queryParams), {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const runs = await response.json();\n    return runs;\n  }\n  async readDatasetSharedSchema(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/datasets/\").concat(datasetId, \"/share\"), {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = \"\".concat(this.getHostUrl(), \"/public/\").concat(shareSchema.share_token, \"/d\");\n    return shareSchema;\n  }\n  async shareDataset(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    const data = {\n      dataset_id: datasetId\n    };\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/datasets/\").concat(datasetId, \"/share\"), {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = \"\".concat(this.getHostUrl(), \"/public/\").concat(shareSchema.share_token, \"/d\");\n    return shareSchema;\n  }\n  async unshareDataset(datasetId) {\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/datasets/\").concat(datasetId, \"/share\"), {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare dataset\");\n  }\n  async readSharedDataset(shareToken) {\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/public/\").concat(shareToken, \"/datasets\"), {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const dataset = await response.json();\n    return dataset;\n  }\n  async createProject(_ref4) {\n    let {\n      projectName,\n      description = null,\n      metadata = null,\n      upsert = false,\n      projectExtra = null,\n      referenceDatasetId = null\n    } = _ref4;\n    const upsert_ = upsert ? \"?upsert=true\" : \"\";\n    const endpoint = \"\".concat(this.apiUrl, \"/sessions\").concat(upsert_);\n    const extra = projectExtra || {};\n    if (metadata) {\n      extra[\"metadata\"] = metadata;\n    }\n    const body = {\n      name: projectName,\n      extra,\n      description\n    };\n    if (referenceDatasetId !== null) {\n      body[\"reference_dataset_id\"] = referenceDatasetId;\n    }\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(\"Failed to create session \".concat(projectName, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    return result;\n  }\n  async updateProject(projectId, _ref5) {\n    let {\n      name = null,\n      description = null,\n      metadata = null,\n      projectExtra = null,\n      endTime = null\n    } = _ref5;\n    const endpoint = \"\".concat(this.apiUrl, \"/sessions/\").concat(projectId);\n    let extra = projectExtra;\n    if (metadata) {\n      extra = {\n        ...(extra || {}),\n        metadata\n      };\n    }\n    const body = {\n      name,\n      extra,\n      description,\n      end_time: endTime ? new Date(endTime).toISOString() : null\n    };\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(\"Failed to update project \".concat(projectId, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    return result;\n  }\n  async readProject(_ref6) {\n    let {\n      projectId,\n      projectName,\n      includeStats\n    } = _ref6;\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += \"/\".concat(projectId);\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    if (includeStats !== undefined) {\n      params.append(\"include_stats\", includeStats.toString());\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(\"Project[id=\".concat(projectId, \", name=\").concat(projectName, \"] not found\"));\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async _getTenantId() {\n    if (this._tenantId !== null) {\n      return this._tenantId;\n    }\n    const queryParams = new URLSearchParams({\n      limit: \"1\"\n    });\n    for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n      this._tenantId = projects[0].tenant_id;\n      return projects[0].tenant_id;\n    }\n    throw new Error(\"No projects found to resolve tenant.\");\n  }\n  listProjects() {\n    try {\n      var _this4 = this;\n      let {\n        projectIds,\n        name,\n        nameContains,\n        referenceDatasetId,\n        referenceDatasetName,\n        referenceFree\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return async function* () {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n          for (const projectId of projectIds) {\n            params.append(\"id\", projectId);\n          }\n        }\n        if (name !== undefined) {\n          params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n          params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n          params.append(\"reference_dataset\", referenceDatasetId);\n        } else if (referenceDatasetName !== undefined) {\n          const dataset = await _this4.readDataset({\n            datasetName: referenceDatasetName\n          });\n          params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n          params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of _this4._getPaginated(\"/sessions\", params)) {\n          yield* projects;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  async deleteProject(_ref7) {\n    let {\n      projectId,\n      projectName\n    } = _ref7;\n    let projectId_;\n    if (projectId === undefined && projectName === undefined) {\n      throw new Error(\"Must provide projectName or projectId\");\n    } else if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId === undefined) {\n      projectId_ = (await this.readProject({\n        projectName\n      })).id;\n    } else {\n      projectId_ = projectId;\n    }\n    assertUuid(projectId_);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/sessions/\").concat(projectId_), {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"delete session \".concat(projectId_, \" (\").concat(projectName, \")\"));\n  }\n  async uploadCsv(_ref8) {\n    let {\n      csvFile,\n      fileName,\n      inputKeys,\n      outputKeys,\n      description,\n      dataType,\n      name\n    } = _ref8;\n    const url = \"\".concat(this.apiUrl, \"/datasets/upload\");\n    const formData = new FormData();\n    formData.append(\"file\", csvFile, fileName);\n    inputKeys.forEach(key => {\n      formData.append(\"input_keys\", key);\n    });\n    outputKeys.forEach(key => {\n      formData.append(\"output_keys\", key);\n    });\n    if (description) {\n      formData.append(\"description\", description);\n    }\n    if (dataType) {\n      formData.append(\"data_type\", dataType);\n    }\n    if (name) {\n      formData.append(\"name\", name);\n    }\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: this.headers,\n      body: formData,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(\"Dataset \".concat(fileName, \" already exists\"));\n      }\n      throw new Error(\"Failed to upload CSV: \".concat(response.status, \" \").concat(response.statusText));\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createDataset(name) {\n    let {\n      description,\n      dataType\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const body = {\n      name,\n      description\n    };\n    if (dataType) {\n      body.data_type = dataType;\n    }\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/datasets\"), {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(\"Dataset \".concat(name, \" already exists\"));\n      }\n      throw new Error(\"Failed to create dataset \".concat(response.status, \" \").concat(response.statusText));\n    }\n    const result = await response.json();\n    return result;\n  }\n  async readDataset(_ref9) {\n    let {\n      datasetId,\n      datasetName\n    } = _ref9;\n    let path = \"/datasets\";\n    // limit to 1 result\n    const params = new URLSearchParams({\n      limit: \"1\"\n    });\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      assertUuid(datasetId);\n      path += \"/\".concat(datasetId);\n    } else if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(\"Dataset[id=\".concat(datasetId, \", name=\").concat(datasetName, \"] not found\"));\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async readDatasetOpenaiFinetuning(_ref10) {\n    let {\n      datasetId,\n      datasetName\n    } = _ref10;\n    const path = \"/datasets\";\n    if (datasetId !== undefined) {\n      // do nothing\n    } else if (datasetName !== undefined) {\n      datasetId = (await this.readDataset({\n        datasetName\n      })).id;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._getResponse(\"\".concat(path, \"/\").concat(datasetId, \"/openai_ft\"));\n    const datasetText = await response.text();\n    const dataset = datasetText.trim().split(\"\\n\").map(line => JSON.parse(line));\n    return dataset;\n  }\n  listDatasets() {\n    try {\n      var _this5 = this;\n      let {\n        limit = 100,\n        offset = 0,\n        datasetIds,\n        datasetName,\n        datasetNameContains\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return async function* () {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n          limit: limit.toString(),\n          offset: offset.toString()\n        });\n        if (datasetIds !== undefined) {\n          for (const id_ of datasetIds) {\n            params.append(\"id\", id_);\n          }\n        }\n        if (datasetName !== undefined) {\n          params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n          params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of _this5._getPaginated(path, params)) {\n          yield* datasets;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  async deleteDataset(_ref11) {\n    let {\n      datasetId,\n      datasetName\n    } = _ref11;\n    let path = \"/datasets\";\n    let datasetId_ = datasetId;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    if (datasetId_ !== undefined) {\n      assertUuid(datasetId_);\n      path += \"/\".concat(datasetId_);\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to delete \".concat(path, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    await response.json();\n  }\n  async createExample(inputs, outputs, _ref12) {\n    let {\n      datasetId,\n      datasetName,\n      createdAt,\n      exampleId\n    } = _ref12;\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const createdAt_ = createdAt || new Date();\n    const data = {\n      dataset_id: datasetId_,\n      inputs,\n      outputs,\n      created_at: createdAt_ === null || createdAt_ === void 0 ? void 0 : createdAt_.toISOString(),\n      id: exampleId\n    };\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/examples\"), {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to create example: \".concat(response.status, \" \").concat(response.statusText));\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createExamples(props) {\n    const {\n      inputs,\n      outputs,\n      sourceRunIds,\n      exampleIds,\n      datasetId,\n      datasetName\n    } = props;\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const formattedExamples = inputs.map((input, idx) => {\n      return {\n        dataset_id: datasetId_,\n        inputs: input,\n        outputs: outputs ? outputs[idx] : undefined,\n        id: exampleIds ? exampleIds[idx] : undefined,\n        source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n      };\n    });\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/examples/bulk\"), {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(formattedExamples),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to create examples: \".concat(response.status, \" \").concat(response.statusText));\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createLLMExample(input, generation, options) {\n    return this.createExample({\n      input\n    }, {\n      output: generation\n    }, options);\n  }\n  async createChatExample(input, generations, options) {\n    const finalInput = input.map(message => {\n      if (isLangChainMessage(message)) {\n        return convertLangChainMessageToExample(message);\n      }\n      return message;\n    });\n    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;\n    return this.createExample({\n      input: finalInput\n    }, {\n      output: finalOutput\n    }, options);\n  }\n  async readExample(exampleId) {\n    assertUuid(exampleId);\n    const path = \"/examples/\".concat(exampleId);\n    return await this._get(path);\n  }\n  listExamples() {\n    try {\n      var _this6 = this;\n      let {\n        datasetId,\n        datasetName,\n        exampleIds\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return async function* () {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n          throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n          datasetId_ = datasetId;\n        } else if (datasetName !== undefined) {\n          const dataset = await _this6.readDataset({\n            datasetName\n          });\n          datasetId_ = dataset.id;\n        } else {\n          throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({\n          dataset: datasetId_\n        });\n        if (exampleIds !== undefined) {\n          for (const id_ of exampleIds) {\n            params.append(\"id\", id_);\n          }\n        }\n        for await (const examples of _this6._getPaginated(\"/examples\", params)) {\n          yield* examples;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  async deleteExample(exampleId) {\n    assertUuid(exampleId);\n    const path = \"/examples/\".concat(exampleId);\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to delete \".concat(path, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    await response.json();\n  }\n  async updateExample(exampleId, update) {\n    assertUuid(exampleId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/examples/\").concat(exampleId), {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(update),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to update example \".concat(exampleId, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    const result = await response.json();\n    return result;\n  }\n  async evaluateRun(run, evaluator) {\n    var _feedbackResult$targe;\n    let {\n      sourceInfo,\n      loadChildRuns,\n      referenceExample\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      loadChildRuns: false\n    };\n    let run_;\n    if (typeof run === \"string\") {\n      run_ = await this.readRun(run, {\n        loadChildRuns\n      });\n    } else if (typeof run === \"object\" && \"id\" in run) {\n      run_ = run;\n    } else {\n      throw new Error(\"Invalid run type: \".concat(typeof run));\n    }\n    if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n      referenceExample = await this.readExample(run_.reference_example_id);\n    }\n    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n    let sourceInfo_ = sourceInfo !== null && sourceInfo !== void 0 ? sourceInfo : {};\n    if (feedbackResult.evaluatorInfo) {\n      sourceInfo_ = {\n        ...sourceInfo_,\n        ...feedbackResult.evaluatorInfo\n      };\n    }\n    const runId = (_feedbackResult$targe = feedbackResult.targetRunId) !== null && _feedbackResult$targe !== void 0 ? _feedbackResult$targe : run_.id;\n    return await this.createFeedback(runId, feedbackResult.key, {\n      score: feedbackResult === null || feedbackResult === void 0 ? void 0 : feedbackResult.score,\n      value: feedbackResult === null || feedbackResult === void 0 ? void 0 : feedbackResult.value,\n      comment: feedbackResult === null || feedbackResult === void 0 ? void 0 : feedbackResult.comment,\n      correction: feedbackResult === null || feedbackResult === void 0 ? void 0 : feedbackResult.correction,\n      sourceInfo: sourceInfo_,\n      feedbackSourceType: \"model\",\n      sourceRunId: feedbackResult === null || feedbackResult === void 0 ? void 0 : feedbackResult.sourceRunId\n    });\n  }\n  async createFeedback(runId, key, _ref13) {\n    var _feedback_source$meta;\n    let {\n      score,\n      value,\n      correction,\n      comment,\n      sourceInfo,\n      feedbackSourceType = \"api\",\n      sourceRunId,\n      feedbackId,\n      eager = false\n    } = _ref13;\n    const feedback_source = {\n      type: feedbackSourceType !== null && feedbackSourceType !== void 0 ? feedbackSourceType : \"api\",\n      metadata: sourceInfo !== null && sourceInfo !== void 0 ? sourceInfo : {}\n    };\n    if (sourceRunId !== undefined && (feedback_source === null || feedback_source === void 0 ? void 0 : feedback_source.metadata) !== undefined && !feedback_source.metadata[\"__run\"]) {\n      feedback_source.metadata[\"__run\"] = {\n        run_id: sourceRunId\n      };\n    }\n    if ((feedback_source === null || feedback_source === void 0 ? void 0 : feedback_source.metadata) !== undefined && ((_feedback_source$meta = feedback_source.metadata[\"__run\"]) === null || _feedback_source$meta === void 0 ? void 0 : _feedback_source$meta.run_id) !== undefined) {\n      assertUuid(feedback_source.metadata[\"__run\"].run_id);\n    }\n    const feedback = {\n      id: feedbackId !== null && feedbackId !== void 0 ? feedbackId : uuid.v4(),\n      run_id: runId,\n      key,\n      score,\n      value,\n      correction,\n      comment,\n      feedback_source: feedback_source\n    };\n    const url = \"\".concat(this.apiUrl, \"/feedback\") + (eager ? \"/eager\" : \"\");\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedback),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create feedback\");\n    return feedback;\n  }\n  async updateFeedback(feedbackId, _ref14) {\n    let {\n      score,\n      value,\n      correction,\n      comment\n    } = _ref14;\n    const feedbackUpdate = {};\n    if (score !== undefined && score !== null) {\n      feedbackUpdate[\"score\"] = score;\n    }\n    if (value !== undefined && value !== null) {\n      feedbackUpdate[\"value\"] = value;\n    }\n    if (correction !== undefined && correction !== null) {\n      feedbackUpdate[\"correction\"] = correction;\n    }\n    if (comment !== undefined && comment !== null) {\n      feedbackUpdate[\"comment\"] = comment;\n    }\n    assertUuid(feedbackId);\n    const response = await this.caller.call(fetch, \"\".concat(this.apiUrl, \"/feedback/\").concat(feedbackId), {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedbackUpdate),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update feedback\");\n  }\n  async readFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = \"/feedback/\".concat(feedbackId);\n    const response = await this._get(path);\n    return response;\n  }\n  async deleteFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = \"/feedback/\".concat(feedbackId);\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to delete \".concat(path, \": \").concat(response.status, \" \").concat(response.statusText));\n    }\n    await response.json();\n  }\n  listFeedback() {\n    try {\n      var _this7 = this;\n      let {\n        runIds,\n        feedbackKeys,\n        feedbackSourceTypes\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return async function* () {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n          queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n          for (const key of feedbackKeys) {\n            queryParams.append(\"key\", key);\n          }\n        }\n        if (feedbackSourceTypes) {\n          for (const type of feedbackSourceTypes) {\n            queryParams.append(\"source\", type);\n          }\n        }\n        for await (const feedbacks of _this7._getPaginated(\"/feedback\", queryParams)) {\n          yield* feedbacks;\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n}","map":{"version":3,"names":["uuid","AsyncCaller","convertLangChainMessageToExample","isLangChainMessage","getEnvironmentVariable","getLangChainEnvVarsMetadata","getRuntimeEnvironment","__version__","mergeRuntimeEnvIntoRunCreates","runs","runtimeEnv","envVars","map","run","_run$extra","_run$revision_id","extra","metadata","runtime","revision_id","getTracingSamplingRate","samplingRateStr","undefined","samplingRate","parseFloat","Error","concat","isLocalhost","url","strippedUrl","replace","hostname","split","raiseForStatus","response","operation","body","text","ok","status","statusText","toArray","iterable","result","item","push","trimQuotes","str","trim","assertUuid","validate","Client","constructor","_trimQuotes","_config$apiUrl","_config$apiKey","_config$webUrl","_config$timeout_ms","_config$callerOptions","_config$hideInputs","_config$hideOutputs","_config$autoBatchTrac","_config$pendingAutoBa","config","arguments","length","Object","defineProperty","enumerable","configurable","writable","value","Set","defaultConfig","getDefaultClientConfig","tracingSampleRate","apiUrl","apiKey","webUrl","validateApiKeyIfHosted","timeout_ms","caller","callerOptions","hideInputs","hideOutputs","autoBatchTracing","pendingAutoBatchedRunLimit","_getEnvironmentVariab","isLocal","getHostUrl","includes","endsWith","headers","processInputs","inputs","processOutputs","outputs","prepareRunCreateOrUpdateInputs","runParams","_getResponse","path","queryParams","_queryParams$toString","paramsString","toString","call","fetch","method","signal","AbortSignal","timeout","_get","json","_getPaginated","_this","URLSearchParams","offset","Number","get","limit","set","String","items","e","Promise","reject","_getCursorPaginatedList","_this2","requestMethod","dataKey","bodyParams","JSON","stringify","responseBody","cursors","next","cursor","_filterForSampling","patch","sampled","sampledPostUuids","has","id","delete","Math","random","add","triggerAutoBatchSend","batch","pendingAutoBatchedRuns","slice","batchIngestRuns","runCreates","filter","action","runUpdates","appendRunCreateToAutoBatchQueue","oldTimeout","autoBatchTimeout","clearTimeout","setTimeout","autoBatchInitialDelayMs","autoBatchAggregationDelayMs","createRun","_run$start_time","session_name","project_name","runCreate","start_time","Date","now","trace_id","dotted_order","mergedRunCreateParams","_ref","_runCreates$map","_runUpdates$map","preparedCreateParams","create","preparedUpdateParams","update","createById","reduce","params","standaloneUpdates","updateParam","values","post","Accept","updateRun","runId","data","readRun","loadChildRuns","child_run_ids","_loadChildRuns","getRunUrl","_ref2","projectOpts","sessionId","session_id","projectName","readProject","projectId","project","tenantId","_getTenantId","run_","app_path","baseUrl","childRuns","listRuns","treemap","sort","a","b","_a$dotted_order","_b$dotted_order","localeCompare","childRun","parent_run_id","child_runs","_ref3","_this3","parentRunId","referenceExampleId","startTime","executionOrder","runType","error","query","projectId_","session","run_type","reference_example","execution_order","parent_run","toISOString","shareRun","shareId","run_id","share_token","v4","unshareRun","readRunSharedLink","listSharedRuns","shareToken","runIds","append","readDatasetSharedSchema","datasetId","datasetName","dataset","readDataset","shareSchema","shareDataset","dataset_id","unshareDataset","readSharedDataset","createProject","_ref4","description","upsert","projectExtra","referenceDatasetId","upsert_","endpoint","name","updateProject","_ref5","endTime","end_time","_ref6","includeStats","Array","isArray","_tenantId","projects","tenant_id","listProjects","_this4","projectIds","nameContains","referenceDatasetName","referenceFree","deleteProject","_ref7","uploadCsv","_ref8","csvFile","fileName","inputKeys","outputKeys","dataType","formData","FormData","forEach","key","detail","createDataset","data_type","_ref9","readDatasetOpenaiFinetuning","_ref10","datasetText","line","parse","listDatasets","_this5","datasetIds","datasetNameContains","id_","datasets","deleteDataset","_ref11","datasetId_","createExample","_ref12","createdAt","exampleId","createdAt_","created_at","createExamples","props","sourceRunIds","exampleIds","formattedExamples","input","idx","source_run_id","createLLMExample","generation","options","output","createChatExample","generations","finalInput","message","finalOutput","readExample","listExamples","_this6","examples","deleteExample","updateExample","evaluateRun","evaluator","_feedbackResult$targe","sourceInfo","referenceExample","reference_example_id","feedbackResult","sourceInfo_","evaluatorInfo","targetRunId","createFeedback","score","comment","correction","feedbackSourceType","sourceRunId","_ref13","_feedback_source$meta","feedbackId","eager","feedback_source","type","feedback","updateFeedback","_ref14","feedbackUpdate","readFeedback","deleteFeedback","listFeedback","_this7","feedbackKeys","feedbackSourceTypes","join","feedbacks"],"sources":["C:/Users/zackb/OneDrive/Desktop/Bootcamp/best_project_ever/client/node_modules/langsmith/dist/client.js"],"sourcesContent":["import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage, } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment, } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n    const runtimeEnv = await getRuntimeEnvironment();\n    const envVars = getLangChainEnvVarsMetadata();\n    return runs.map((run) => {\n        const extra = run.extra ?? {};\n        const metadata = extra.metadata;\n        run.extra = {\n            ...extra,\n            runtime: {\n                ...runtimeEnv,\n                ...extra?.runtime,\n            },\n            metadata: {\n                ...envVars,\n                ...(envVars.revision_id || run.revision_id\n                    ? { revision_id: run.revision_id ?? envVars.revision_id }\n                    : {}),\n                ...metadata,\n            },\n        };\n        return run;\n    });\n}\nconst getTracingSamplingRate = () => {\n    const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nconst raiseForStatus = async (response, operation) => {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n    if (!uuid.validate(str)) {\n        throw new Error(`Invalid UUID: ${str}`);\n    }\n}\nexport class Client {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sampledPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRuns\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        this.validateApiKeyIfHosted();\n        this.timeout_ms = config.timeout_ms ?? 12000;\n        this.caller = new AsyncCaller(config.callerOptions ?? {});\n        this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.pendingAutoBatchedRunLimit =\n            config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n    }\n    static getDefaultClientConfig() {\n        const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n        const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ??\n            \"https://api.smith.langchain.com\";\n        const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n        const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    validateApiKeyIfHosted() {\n        const isLocal = isLocalhost(this.apiUrl);\n        if (!isLocal && !this.apiKey) {\n            throw new Error(\"API key must be provided when using hosted LangSmith API\");\n        }\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost\";\n            return \"http://localhost\";\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return \"https://dev.smith.langchain.com\";\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return \"https://smith.langchain.com\";\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs) {\n            return {};\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs) {\n            return {};\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                body: JSON.stringify(bodyParams),\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (this.sampledPostUuids.has(run.id)) {\n                    sampled.push(run);\n                    this.sampledPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            const sampled = [];\n            for (const run of runs) {\n                if (Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                    this.sampledPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async triggerAutoBatchSend(runs) {\n        let batch = runs;\n        if (batch === undefined) {\n            batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n            this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n        }\n        await this.batchIngestRuns({\n            runCreates: batch\n                .filter((item) => item.action === \"create\")\n                .map((item) => item.item),\n            runUpdates: batch\n                .filter((item) => item.action === \"update\")\n                .map((item) => item.item),\n        });\n    }\n    appendRunCreateToAutoBatchQueue(item) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        this.pendingAutoBatchedRuns.push(item);\n        while (this.pendingAutoBatchedRuns.length >= this.pendingAutoBatchedRunLimit) {\n            const batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n            this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n            void this.triggerAutoBatchSend(batch);\n        }\n        if (this.pendingAutoBatchedRuns.length > 0) {\n            if (!oldTimeout) {\n                this.autoBatchTimeout = setTimeout(() => {\n                    this.autoBatchTimeout = undefined;\n                    void this.triggerAutoBatchSend();\n                }, this.autoBatchInitialDelayMs);\n            }\n            else {\n                this.autoBatchTimeout = setTimeout(() => {\n                    this.autoBatchTimeout = undefined;\n                    void this.triggerAutoBatchSend();\n                }, this.autoBatchAggregationDelayMs);\n            }\n        }\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            this.appendRunCreateToAutoBatchQueue({\n                action: \"create\",\n                item: runCreate,\n            });\n            return;\n        }\n        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n            runCreate,\n        ]);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(mergedRunCreateParams[0]),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const body = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true),\n        };\n        if (!body.post.length && !body.patch.length) {\n            return;\n        }\n        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"batch create run\");\n    }\n    async updateRun(runId, run) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            this.appendRunCreateToAutoBatchQueue({ action: \"update\", item: data });\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    async *listRuns({ projectId, projectName, parentRunId, referenceExampleId, startTime, executionOrder, runType, error, id, query, filter, limit, }) {\n        let projectId_ = projectId;\n        if (projectName) {\n            if (projectId) {\n                throw new Error(\"Only one of projectId or projectName may be given\");\n            }\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        const body = {\n            session: projectId_ ? [projectId_] : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            execution_order: executionOrder,\n            parent_run: parentRunId ? [parentRunId] : null,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n        };\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            yield* runs;\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid.v4(),\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare dataset\");\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        };\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, } = {}) {\n        const body = {\n            name,\n            description,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId,\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, sourceRunIds, exampleIds, datasetId, datasetName, } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined,\n            };\n        });\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if (isLangChainMessage(message)) {\n                return convertLangChainMessageToExample(message);\n            }\n            return message;\n        });\n        const finalOutput = isLangChainMessage(generations)\n            ? convertLangChainMessageToExample(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)) {\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        assertUuid(exampleId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = { ...sourceInfo_, ...feedbackResult.evaluatorInfo };\n        }\n        const runId = feedbackResult.targetRunId ?? run_.id;\n        return await this.createFeedback(runId, feedbackResult.key, {\n            score: feedbackResult?.score,\n            value: feedbackResult?.value,\n            comment: feedbackResult?.comment,\n            correction: feedbackResult?.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"model\",\n            sourceRunId: feedbackResult?.sourceRunId,\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, eager = false, }) {\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid.v4(),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n        };\n        const url = `${this.apiUrl}/feedback` + (eager ? \"/eager\" : \"\");\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create feedback\");\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update feedback\");\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,MAAM;AAC5B,SAASC,WAAW,QAAQ,yBAAyB;AACrD,SAASC,gCAAgC,EAAEC,kBAAkB,QAAS,qBAAqB;AAC3F,SAASC,sBAAsB,EAAEC,2BAA2B,EAAEC,qBAAqB,QAAS,gBAAgB;AAC5G,SAASC,WAAW,QAAQ,YAAY;AACxC,eAAeC,6BAA6BA,CAACC,IAAI,EAAE;EAC/C,MAAMC,UAAU,GAAG,MAAMJ,qBAAqB,CAAC,CAAC;EAChD,MAAMK,OAAO,GAAGN,2BAA2B,CAAC,CAAC;EAC7C,OAAOI,IAAI,CAACG,GAAG,CAAEC,GAAG,IAAK;IAAA,IAAAC,UAAA,EAAAC,gBAAA;IACrB,MAAMC,KAAK,IAAAF,UAAA,GAAGD,GAAG,CAACG,KAAK,cAAAF,UAAA,cAAAA,UAAA,GAAI,CAAC,CAAC;IAC7B,MAAMG,QAAQ,GAAGD,KAAK,CAACC,QAAQ;IAC/BJ,GAAG,CAACG,KAAK,GAAG;MACR,GAAGA,KAAK;MACRE,OAAO,EAAE;QACL,GAAGR,UAAU;QACb,IAAGM,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEE,OAAO;MACrB,CAAC;MACDD,QAAQ,EAAE;QACN,GAAGN,OAAO;QACV,IAAIA,OAAO,CAACQ,WAAW,IAAIN,GAAG,CAACM,WAAW,GACpC;UAAEA,WAAW,GAAAJ,gBAAA,GAAEF,GAAG,CAACM,WAAW,cAAAJ,gBAAA,cAAAA,gBAAA,GAAIJ,OAAO,CAACQ;QAAY,CAAC,GACvD,CAAC,CAAC,CAAC;QACT,GAAGF;MACP;IACJ,CAAC;IACD,OAAOJ,GAAG;EACd,CAAC,CAAC;AACN;AACA,MAAMO,sBAAsB,GAAGA,CAAA,KAAM;EACjC,MAAMC,eAAe,GAAGjB,sBAAsB,CAAC,iCAAiC,CAAC;EACjF,IAAIiB,eAAe,KAAKC,SAAS,EAAE;IAC/B,OAAOA,SAAS;EACpB;EACA,MAAMC,YAAY,GAAGC,UAAU,CAACH,eAAe,CAAC;EAChD,IAAIE,YAAY,GAAG,CAAC,IAAIA,YAAY,GAAG,CAAC,EAAE;IACtC,MAAM,IAAIE,KAAK,yEAAAC,MAAA,CAAyEH,YAAY,CAAE,CAAC;EAC3G;EACA,OAAOA,YAAY;AACvB,CAAC;AACD;AACA,MAAMI,WAAW,GAAIC,GAAG,IAAK;EACzB,MAAMC,WAAW,GAAGD,GAAG,CAACE,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC;EACtE,MAAMC,QAAQ,GAAGF,WAAW,CAACG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACA,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACxD,OAAQD,QAAQ,KAAK,WAAW,IAAIA,QAAQ,KAAK,WAAW,IAAIA,QAAQ,KAAK,KAAK;AACtF,CAAC;AACD,MAAME,cAAc,GAAG,MAAAA,CAAOC,QAAQ,EAAEC,SAAS,KAAK;EAClD;EACA;EACA,MAAMC,IAAI,GAAG,MAAMF,QAAQ,CAACG,IAAI,CAAC,CAAC;EAClC,IAAI,CAACH,QAAQ,CAACI,EAAE,EAAE;IACd,MAAM,IAAIb,KAAK,cAAAC,MAAA,CAAcS,SAAS,QAAAT,MAAA,CAAKQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,OAAAd,MAAA,CAAIU,IAAI,CAAE,CAAC;EAChG;AACJ,CAAC;AACD,eAAeK,OAAOA,CAACC,QAAQ,EAAE;EAC7B,MAAMC,MAAM,GAAG,EAAE;EACjB,WAAW,MAAMC,IAAI,IAAIF,QAAQ,EAAE;IAC/BC,MAAM,CAACE,IAAI,CAACD,IAAI,CAAC;EACrB;EACA,OAAOD,MAAM;AACjB;AACA,SAASG,UAAUA,CAACC,GAAG,EAAE;EACrB,IAAIA,GAAG,KAAKzB,SAAS,EAAE;IACnB,OAAOA,SAAS;EACpB;EACA,OAAOyB,GAAG,CACLC,IAAI,CAAC,CAAC,CACNlB,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,CACzBA,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;AAClC;AACA,SAASmB,UAAUA,CAACF,GAAG,EAAE;EACrB,IAAI,CAAC/C,IAAI,CAACkD,QAAQ,CAACH,GAAG,CAAC,EAAE;IACrB,MAAM,IAAItB,KAAK,kBAAAC,MAAA,CAAkBqB,GAAG,CAAE,CAAC;EAC3C;AACJ;AACA,OAAO,MAAMI,MAAM,CAAC;EAChBC,WAAWA,CAAA,EAAc;IAAA,IAAAC,WAAA,EAAAC,cAAA,EAAAC,cAAA,EAAAC,cAAA,EAAAC,kBAAA,EAAAC,qBAAA,EAAAC,kBAAA,EAAAC,mBAAA,EAAAC,qBAAA,EAAAC,qBAAA;IAAA,IAAbC,MAAM,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,CAAC,CAAC;IACnBE,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,YAAY,EAAE;MACtCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,WAAW,EAAE;MACrCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,YAAY,EAAE;MACtCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,aAAa,EAAE;MACvCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,mBAAmB,EAAE;MAC7CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,kBAAkB,EAAE;MAC5CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,IAAIC,GAAG,CAAC;IACnB,CAAC,CAAC;IACFN,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,kBAAkB,EAAE;MAC5CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,wBAAwB,EAAE;MAClDC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,4BAA4B,EAAE;MACtDC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,kBAAkB,EAAE;MAC5CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,yBAAyB,EAAE;MACnDC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,6BAA6B,EAAE;MACvDC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACF,MAAME,aAAa,GAAGtB,MAAM,CAACuB,sBAAsB,CAAC,CAAC;IACrD,IAAI,CAACC,iBAAiB,GAAGvD,sBAAsB,CAAC,CAAC;IACjD,IAAI,CAACwD,MAAM,IAAAvB,WAAA,GAAGP,UAAU,EAAAQ,cAAA,GAACS,MAAM,CAACa,MAAM,cAAAtB,cAAA,cAAAA,cAAA,GAAImB,aAAa,CAACG,MAAM,CAAC,cAAAvB,WAAA,cAAAA,WAAA,GAAI,EAAE;IACrE,IAAI,CAACwB,MAAM,GAAG/B,UAAU,EAAAS,cAAA,GAACQ,MAAM,CAACc,MAAM,cAAAtB,cAAA,cAAAA,cAAA,GAAIkB,aAAa,CAACI,MAAM,CAAC;IAC/D,IAAI,CAACC,MAAM,GAAGhC,UAAU,EAAAU,cAAA,GAACO,MAAM,CAACe,MAAM,cAAAtB,cAAA,cAAAA,cAAA,GAAIiB,aAAa,CAACK,MAAM,CAAC;IAC/D,IAAI,CAACC,sBAAsB,CAAC,CAAC;IAC7B,IAAI,CAACC,UAAU,IAAAvB,kBAAA,GAAGM,MAAM,CAACiB,UAAU,cAAAvB,kBAAA,cAAAA,kBAAA,GAAI,KAAK;IAC5C,IAAI,CAACwB,MAAM,GAAG,IAAIhF,WAAW,EAAAyD,qBAAA,GAACK,MAAM,CAACmB,aAAa,cAAAxB,qBAAA,cAAAA,qBAAA,GAAI,CAAC,CAAC,CAAC;IACzD,IAAI,CAACyB,UAAU,IAAAxB,kBAAA,GAAGI,MAAM,CAACoB,UAAU,cAAAxB,kBAAA,cAAAA,kBAAA,GAAIc,aAAa,CAACU,UAAU;IAC/D,IAAI,CAACC,WAAW,IAAAxB,mBAAA,GAAGG,MAAM,CAACqB,WAAW,cAAAxB,mBAAA,cAAAA,mBAAA,GAAIa,aAAa,CAACW,WAAW;IAClE,IAAI,CAACC,gBAAgB,IAAAxB,qBAAA,GAAGE,MAAM,CAACsB,gBAAgB,cAAAxB,qBAAA,cAAAA,qBAAA,GAAI,IAAI,CAACwB,gBAAgB;IACxE,IAAI,CAACC,0BAA0B,IAAAxB,qBAAA,GAC3BC,MAAM,CAACuB,0BAA0B,cAAAxB,qBAAA,cAAAA,qBAAA,GAAI,IAAI,CAACwB,0BAA0B;EAC5E;EACA,OAAOZ,sBAAsBA,CAAA,EAAG;IAAA,IAAAa,qBAAA;IAC5B,MAAMV,MAAM,GAAGzE,sBAAsB,CAAC,mBAAmB,CAAC;IAC1D,MAAMwE,MAAM,IAAAW,qBAAA,GAAGnF,sBAAsB,CAAC,oBAAoB,CAAC,cAAAmF,qBAAA,cAAAA,qBAAA,GACvD,iCAAiC;IACrC,MAAMJ,UAAU,GAAG/E,sBAAsB,CAAC,uBAAuB,CAAC,KAAK,MAAM;IAC7E,MAAMgF,WAAW,GAAGhF,sBAAsB,CAAC,wBAAwB,CAAC,KAAK,MAAM;IAC/E,OAAO;MACHwE,MAAM,EAAEA,MAAM;MACdC,MAAM,EAAEA,MAAM;MACdC,MAAM,EAAExD,SAAS;MACjB6D,UAAU,EAAEA,UAAU;MACtBC,WAAW,EAAEA;IACjB,CAAC;EACL;EACAL,sBAAsBA,CAAA,EAAG;IACrB,MAAMS,OAAO,GAAG7D,WAAW,CAAC,IAAI,CAACiD,MAAM,CAAC;IACxC,IAAI,CAACY,OAAO,IAAI,CAAC,IAAI,CAACX,MAAM,EAAE;MAC1B,MAAM,IAAIpD,KAAK,CAAC,0DAA0D,CAAC;IAC/E;EACJ;EACAgE,UAAUA,CAAA,EAAG;IACT,IAAI,IAAI,CAACX,MAAM,EAAE;MACb,OAAO,IAAI,CAACA,MAAM;IACtB,CAAC,MACI,IAAInD,WAAW,CAAC,IAAI,CAACiD,MAAM,CAAC,EAAE;MAC/B,IAAI,CAACE,MAAM,GAAG,kBAAkB;MAChC,OAAO,kBAAkB;IAC7B,CAAC,MACI,IAAI,IAAI,CAACF,MAAM,CAACc,QAAQ,CAAC,MAAM,CAAC,IACjC,CAAC,IAAI,CAACd,MAAM,CAAC5C,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC2D,QAAQ,CAAC,KAAK,CAAC,EAAE;MAC/C,IAAI,CAACb,MAAM,GAAG,IAAI,CAACF,MAAM,CAAC9C,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;MAC7C,OAAO,IAAI,CAACgD,MAAM;IACtB,CAAC,MACI,IAAI,IAAI,CAACF,MAAM,CAAC5C,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC0D,QAAQ,CAAC,KAAK,CAAC,EAAE;MACnD,IAAI,CAACZ,MAAM,GAAG,iCAAiC;MAC/C,OAAO,iCAAiC;IAC5C,CAAC,MACI;MACD,IAAI,CAACA,MAAM,GAAG,6BAA6B;MAC3C,OAAO,6BAA6B;IACxC;EACJ;EACA,IAAIc,OAAOA,CAAA,EAAG;IACV,MAAMA,OAAO,GAAG;MACZ,YAAY,kBAAAlE,MAAA,CAAkBnB,WAAW;IAC7C,CAAC;IACD,IAAI,IAAI,CAACsE,MAAM,EAAE;MACbe,OAAO,CAAC,WAAW,CAAC,MAAAlE,MAAA,CAAM,IAAI,CAACmD,MAAM,CAAE;IAC3C;IACA,OAAOe,OAAO;EAClB;EACAC,aAAaA,CAACC,MAAM,EAAE;IAClB,IAAI,IAAI,CAACX,UAAU,EAAE;MACjB,OAAO,CAAC,CAAC;IACb;IACA,OAAOW,MAAM;EACjB;EACAC,cAAcA,CAACC,OAAO,EAAE;IACpB,IAAI,IAAI,CAACZ,WAAW,EAAE;MAClB,OAAO,CAAC,CAAC;IACb;IACA,OAAOY,OAAO;EAClB;EACAC,8BAA8BA,CAACpF,GAAG,EAAE;IAChC,MAAMqF,SAAS,GAAG;MAAE,GAAGrF;IAAI,CAAC;IAC5B,IAAIqF,SAAS,CAACJ,MAAM,KAAKxE,SAAS,EAAE;MAChC4E,SAAS,CAACJ,MAAM,GAAG,IAAI,CAACD,aAAa,CAACK,SAAS,CAACJ,MAAM,CAAC;IAC3D;IACA,IAAII,SAAS,CAACF,OAAO,KAAK1E,SAAS,EAAE;MACjC4E,SAAS,CAACF,OAAO,GAAG,IAAI,CAACD,cAAc,CAACG,SAAS,CAACF,OAAO,CAAC;IAC9D;IACA,OAAOE,SAAS;EACpB;EACA,MAAMC,YAAYA,CAACC,IAAI,EAAEC,WAAW,EAAE;IAAA,IAAAC,qBAAA;IAClC,MAAMC,YAAY,IAAAD,qBAAA,GAAGD,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEG,QAAQ,CAAC,CAAC,cAAAF,qBAAA,cAAAA,qBAAA,GAAI,EAAE;IAClD,MAAM1E,GAAG,MAAAF,MAAA,CAAM,IAAI,CAACkD,MAAM,EAAAlD,MAAA,CAAG0E,IAAI,OAAA1E,MAAA,CAAI6E,YAAY,CAAE;IACnD,MAAMrE,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,EAAE9E,GAAG,EAAE;MAChD+E,MAAM,EAAE,KAAK;MACbf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,IAAI,CAAC9C,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIb,KAAK,oBAAAC,MAAA,CAAoB0E,IAAI,QAAA1E,MAAA,CAAKQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IACzF;IACA,OAAON,QAAQ;EACnB;EACA,MAAM6E,IAAIA,CAACX,IAAI,EAAEC,WAAW,EAAE;IAC1B,MAAMnE,QAAQ,GAAG,MAAM,IAAI,CAACiE,YAAY,CAACC,IAAI,EAAEC,WAAW,CAAC;IAC3D,OAAOnE,QAAQ,CAAC8E,IAAI,CAAC,CAAC;EAC1B;EACOC,aAAaA,CAACb,IAAI;IAAA;MAAA,IAAAc,KAAA;MAAA,IAAEb,WAAW,GAAArC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,IAAImD,eAAe,CAAC,CAAC;MAAA,0BAAE;QAC5D,IAAIC,MAAM,GAAGC,MAAM,CAAChB,WAAW,CAACiB,GAAG,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC;QACnD,MAAMC,KAAK,GAAGF,MAAM,CAAChB,WAAW,CAACiB,GAAG,CAAC,OAAO,CAAC,CAAC,IAAI,GAAG;QACrD,OAAO,IAAI,EAAE;UACTjB,WAAW,CAACmB,GAAG,CAAC,QAAQ,EAAEC,MAAM,CAACL,MAAM,CAAC,CAAC;UACzCf,WAAW,CAACmB,GAAG,CAAC,OAAO,EAAEC,MAAM,CAACF,KAAK,CAAC,CAAC;UACvC,MAAM3F,GAAG,MAAAF,MAAA,CAAMwF,KAAI,CAACtC,MAAM,EAAAlD,MAAA,CAAG0E,IAAI,OAAA1E,MAAA,CAAI2E,WAAW,CAAE;UAClD,MAAMnE,QAAQ,GAAG,MAAMgF,KAAI,CAACjC,MAAM,CAACwB,IAAI,CAACC,KAAK,EAAE9E,GAAG,EAAE;YAChD+E,MAAM,EAAE,KAAK;YACbf,OAAO,EAAEsB,KAAI,CAACtB,OAAO;YACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAACI,KAAI,CAAClC,UAAU;UAC/C,CAAC,CAAC;UACF,IAAI,CAAC9C,QAAQ,CAACI,EAAE,EAAE;YACd,MAAM,IAAIb,KAAK,oBAAAC,MAAA,CAAoB0E,IAAI,QAAA1E,MAAA,CAAKQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;UACzF;UACA,MAAMkF,KAAK,GAAG,MAAMxF,QAAQ,CAAC8E,IAAI,CAAC,CAAC;UACnC,IAAIU,KAAK,CAACzD,MAAM,KAAK,CAAC,EAAE;YACpB;UACJ;UACA,MAAMyD,KAAK;UACX,IAAIA,KAAK,CAACzD,MAAM,GAAGsD,KAAK,EAAE;YACtB;UACJ;UACAH,MAAM,IAAIM,KAAK,CAACzD,MAAM;QAC1B;MACJ,CAAC;IAAA,SAAA0D,CAAA;MAAA,OAAAC,OAAA,CAAAC,MAAA,CAAAF,CAAA;IAAA;EAAA;EACMG,uBAAuBA,CAAC1B,IAAI;IAAA;MAAA,IAAA2B,MAAA;MAAA,IAAE3F,IAAI,GAAA4B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,IAAI;MAAA,IAAEgE,aAAa,GAAAhE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,MAAM;MAAA,IAAEiE,OAAO,GAAAjE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,MAAM;MAAA,0BAAE;QACxF,MAAMkE,UAAU,GAAG9F,IAAI,GAAG;UAAE,GAAGA;QAAK,CAAC,GAAG,CAAC,CAAC;QAC1C,OAAO,IAAI,EAAE;UACT,MAAMF,QAAQ,GAAG,MAAM6F,MAAI,CAAC9C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAKqG,MAAI,CAACnD,MAAM,EAAAlD,MAAA,CAAG0E,IAAI,GAAI;YACpEO,MAAM,EAAEqB,aAAa;YACrBpC,OAAO,EAAE;cAAE,GAAGmC,MAAI,CAACnC,OAAO;cAAE,cAAc,EAAE;YAAmB,CAAC;YAChEgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAACiB,MAAI,CAAC/C,UAAU,CAAC;YAC5C5C,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAACF,UAAU;UACnC,CAAC,CAAC;UACF,MAAMG,YAAY,GAAG,MAAMnG,QAAQ,CAAC8E,IAAI,CAAC,CAAC;UAC1C,IAAI,CAACqB,YAAY,EAAE;YACf;UACJ;UACA,IAAI,CAACA,YAAY,CAACJ,OAAO,CAAC,EAAE;YACxB;UACJ;UACA,MAAMI,YAAY,CAACJ,OAAO,CAAC;UAC3B,MAAMK,OAAO,GAAGD,YAAY,CAACC,OAAO;UACpC,IAAI,CAACA,OAAO,EAAE;YACV;UACJ;UACA,IAAI,CAACA,OAAO,CAACC,IAAI,EAAE;YACf;UACJ;UACAL,UAAU,CAACM,MAAM,GAAGF,OAAO,CAACC,IAAI;QACpC;MACJ,CAAC;IAAA,SAAAZ,CAAA;MAAA,OAAAC,OAAA,CAAAC,MAAA,CAAAF,CAAA;IAAA;EAAA;EACDc,kBAAkBA,CAAChI,IAAI,EAAiB;IAAA,IAAfiI,KAAK,GAAA1E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,KAAK;IAClC,IAAI,IAAI,CAACW,iBAAiB,KAAKrD,SAAS,EAAE;MACtC,OAAOb,IAAI;IACf;IACA,IAAIiI,KAAK,EAAE;MACP,MAAMC,OAAO,GAAG,EAAE;MAClB,KAAK,MAAM9H,GAAG,IAAIJ,IAAI,EAAE;QACpB,IAAI,IAAI,CAACmI,gBAAgB,CAACC,GAAG,CAAChI,GAAG,CAACiI,EAAE,CAAC,EAAE;UACnCH,OAAO,CAAC9F,IAAI,CAAChC,GAAG,CAAC;UACjB,IAAI,CAAC+H,gBAAgB,CAACG,MAAM,CAAClI,GAAG,CAACiI,EAAE,CAAC;QACxC;MACJ;MACA,OAAOH,OAAO;IAClB,CAAC,MACI;MACD,MAAMA,OAAO,GAAG,EAAE;MAClB,KAAK,MAAM9H,GAAG,IAAIJ,IAAI,EAAE;QACpB,IAAIuI,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,IAAI,CAACtE,iBAAiB,EAAE;UACxCgE,OAAO,CAAC9F,IAAI,CAAChC,GAAG,CAAC;UACjB,IAAI,CAAC+H,gBAAgB,CAACM,GAAG,CAACrI,GAAG,CAACiI,EAAE,CAAC;QACrC;MACJ;MACA,OAAOH,OAAO;IAClB;EACJ;EACA,MAAMQ,oBAAoBA,CAAC1I,IAAI,EAAE;IAC7B,IAAI2I,KAAK,GAAG3I,IAAI;IAChB,IAAI2I,KAAK,KAAK9H,SAAS,EAAE;MACrB8H,KAAK,GAAG,IAAI,CAACC,sBAAsB,CAACC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAChE,0BAA0B,CAAC;MAC7E,IAAI,CAAC+D,sBAAsB,GAAG,IAAI,CAACA,sBAAsB,CAACC,KAAK,CAAC,IAAI,CAAChE,0BAA0B,CAAC;IACpG;IACA,MAAM,IAAI,CAACiE,eAAe,CAAC;MACvBC,UAAU,EAAEJ,KAAK,CACZK,MAAM,CAAE7G,IAAI,IAAKA,IAAI,CAAC8G,MAAM,KAAK,QAAQ,CAAC,CAC1C9I,GAAG,CAAEgC,IAAI,IAAKA,IAAI,CAACA,IAAI,CAAC;MAC7B+G,UAAU,EAAEP,KAAK,CACZK,MAAM,CAAE7G,IAAI,IAAKA,IAAI,CAAC8G,MAAM,KAAK,QAAQ,CAAC,CAC1C9I,GAAG,CAAEgC,IAAI,IAAKA,IAAI,CAACA,IAAI;IAChC,CAAC,CAAC;EACN;EACAgH,+BAA+BA,CAAChH,IAAI,EAAE;IAClC,MAAMiH,UAAU,GAAG,IAAI,CAACC,gBAAgB;IACxCC,YAAY,CAAC,IAAI,CAACD,gBAAgB,CAAC;IACnC,IAAI,CAACA,gBAAgB,GAAGxI,SAAS;IACjC,IAAI,CAAC+H,sBAAsB,CAACxG,IAAI,CAACD,IAAI,CAAC;IACtC,OAAO,IAAI,CAACyG,sBAAsB,CAACpF,MAAM,IAAI,IAAI,CAACqB,0BAA0B,EAAE;MAC1E,MAAM8D,KAAK,GAAG,IAAI,CAACC,sBAAsB,CAACC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAChE,0BAA0B,CAAC;MACnF,IAAI,CAAC+D,sBAAsB,GAAG,IAAI,CAACA,sBAAsB,CAACC,KAAK,CAAC,IAAI,CAAChE,0BAA0B,CAAC;MAChG,KAAK,IAAI,CAAC6D,oBAAoB,CAACC,KAAK,CAAC;IACzC;IACA,IAAI,IAAI,CAACC,sBAAsB,CAACpF,MAAM,GAAG,CAAC,EAAE;MACxC,IAAI,CAAC4F,UAAU,EAAE;QACb,IAAI,CAACC,gBAAgB,GAAGE,UAAU,CAAC,MAAM;UACrC,IAAI,CAACF,gBAAgB,GAAGxI,SAAS;UACjC,KAAK,IAAI,CAAC6H,oBAAoB,CAAC,CAAC;QACpC,CAAC,EAAE,IAAI,CAACc,uBAAuB,CAAC;MACpC,CAAC,MACI;QACD,IAAI,CAACH,gBAAgB,GAAGE,UAAU,CAAC,MAAM;UACrC,IAAI,CAACF,gBAAgB,GAAGxI,SAAS;UACjC,KAAK,IAAI,CAAC6H,oBAAoB,CAAC,CAAC;QACpC,CAAC,EAAE,IAAI,CAACe,2BAA2B,CAAC;MACxC;IACJ;EACJ;EACA,MAAMC,SAASA,CAACtJ,GAAG,EAAE;IAAA,IAAAuJ,eAAA;IACjB,IAAI,CAAC,IAAI,CAAC3B,kBAAkB,CAAC,CAAC5H,GAAG,CAAC,CAAC,CAACoD,MAAM,EAAE;MACxC;IACJ;IACA,MAAM2B,OAAO,GAAG;MAAE,GAAG,IAAI,CAACA,OAAO;MAAE,cAAc,EAAE;IAAmB,CAAC;IACvE,MAAMyE,YAAY,GAAGxJ,GAAG,CAACyJ,YAAY;IACrC,OAAOzJ,GAAG,CAACyJ,YAAY;IACvB,MAAMC,SAAS,GAAG,IAAI,CAACtE,8BAA8B,CAAC;MAClDoE,YAAY;MACZ,GAAGxJ,GAAG;MACN2J,UAAU,GAAAJ,eAAA,GAAEvJ,GAAG,CAAC2J,UAAU,cAAAJ,eAAA,cAAAA,eAAA,GAAIK,IAAI,CAACC,GAAG,CAAC;IAC3C,CAAC,CAAC;IACF,IAAI,IAAI,CAACrF,gBAAgB,IACrBkF,SAAS,CAACI,QAAQ,KAAKrJ,SAAS,IAChCiJ,SAAS,CAACK,YAAY,KAAKtJ,SAAS,EAAE;MACtC,IAAI,CAACsI,+BAA+B,CAAC;QACjCF,MAAM,EAAE,QAAQ;QAChB9G,IAAI,EAAE2H;MACV,CAAC,CAAC;MACF;IACJ;IACA,MAAMM,qBAAqB,GAAG,MAAMrK,6BAA6B,CAAC,CAC9D+J,SAAS,CACZ,CAAC;IACF,MAAMrI,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,YAAS;MAClE+B,MAAM,EAAE,MAAM;MACdf,OAAO;MACPxD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAACyC,qBAAqB,CAAC,CAAC,CAAC,CAAC;MAC9CjE,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM/C,cAAc,CAACC,QAAQ,EAAE,YAAY,CAAC;EAChD;EACA;AACJ;AACA;AACA;EACI,MAAMqH,eAAeA,CAAAuB,IAAA,EAA8B;IAAA,IAAAC,eAAA,EAAAC,eAAA;IAAA,IAA7B;MAAExB,UAAU;MAAEG;IAAY,CAAC,GAAAmB,IAAA;IAC7C,IAAItB,UAAU,KAAKlI,SAAS,IAAIqI,UAAU,KAAKrI,SAAS,EAAE;MACtD;IACJ;IACA,IAAI2J,oBAAoB,IAAAF,eAAA,GAAGvB,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE5I,GAAG,CAAEsK,MAAM,IAAK,IAAI,CAACjF,8BAA8B,CAACiF,MAAM,CAAC,CAAC,cAAAH,eAAA,cAAAA,eAAA,GAAI,EAAE;IACzG,IAAII,oBAAoB,IAAAH,eAAA,GAAGrB,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAE/I,GAAG,CAAEwK,MAAM,IAAK,IAAI,CAACnF,8BAA8B,CAACmF,MAAM,CAAC,CAAC,cAAAJ,eAAA,cAAAA,eAAA,GAAI,EAAE;IACzG,IAAIC,oBAAoB,CAAChH,MAAM,GAAG,CAAC,IAAIkH,oBAAoB,CAAClH,MAAM,GAAG,CAAC,EAAE;MACpE,MAAMoH,UAAU,GAAGJ,oBAAoB,CAACK,MAAM,CAAC,CAACC,MAAM,EAAE1K,GAAG,KAAK;QAC5D,IAAI,CAACA,GAAG,CAACiI,EAAE,EAAE;UACT,OAAOyC,MAAM;QACjB;QACAA,MAAM,CAAC1K,GAAG,CAACiI,EAAE,CAAC,GAAGjI,GAAG;QACpB,OAAO0K,MAAM;MACjB,CAAC,EAAE,CAAC,CAAC,CAAC;MACN,MAAMC,iBAAiB,GAAG,EAAE;MAC5B,KAAK,MAAMC,WAAW,IAAIN,oBAAoB,EAAE;QAC5C,IAAIM,WAAW,CAAC3C,EAAE,KAAKxH,SAAS,IAAI+J,UAAU,CAACI,WAAW,CAAC3C,EAAE,CAAC,EAAE;UAC5DuC,UAAU,CAACI,WAAW,CAAC3C,EAAE,CAAC,GAAG;YACzB,GAAGuC,UAAU,CAACI,WAAW,CAAC3C,EAAE,CAAC;YAC7B,GAAG2C;UACP,CAAC;QACL,CAAC,MACI;UACDD,iBAAiB,CAAC3I,IAAI,CAAC4I,WAAW,CAAC;QACvC;MACJ;MACAR,oBAAoB,GAAG/G,MAAM,CAACwH,MAAM,CAACL,UAAU,CAAC;MAChDF,oBAAoB,GAAGK,iBAAiB;IAC5C;IACA,MAAMpJ,IAAI,GAAG;MACTuJ,IAAI,EAAE,IAAI,CAAClD,kBAAkB,CAACwC,oBAAoB,CAAC;MACnDvC,KAAK,EAAE,IAAI,CAACD,kBAAkB,CAAC0C,oBAAoB,EAAE,IAAI;IAC7D,CAAC;IACD,IAAI,CAAC/I,IAAI,CAACuJ,IAAI,CAAC1H,MAAM,IAAI,CAAC7B,IAAI,CAACsG,KAAK,CAACzE,MAAM,EAAE;MACzC;IACJ;IACAgH,oBAAoB,GAAG,MAAMzK,6BAA6B,CAACyK,oBAAoB,CAAC;IAChF,MAAMrF,OAAO,GAAG;MACZ,GAAG,IAAI,CAACA,OAAO;MACf,cAAc,EAAE,kBAAkB;MAClCgG,MAAM,EAAE;IACZ,CAAC;IACD,MAAM1J,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,kBAAe;MACxE+B,MAAM,EAAE,MAAM;MACdf,OAAO;MACPxD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAAChG,IAAI,CAAC;MAC1BwE,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM/C,cAAc,CAACC,QAAQ,EAAE,kBAAkB,CAAC;EACtD;EACA,MAAM2J,SAASA,CAACC,KAAK,EAAEjL,GAAG,EAAE;IACxBoC,UAAU,CAAC6I,KAAK,CAAC;IACjB,IAAIjL,GAAG,CAACiF,MAAM,EAAE;MACZjF,GAAG,CAACiF,MAAM,GAAG,IAAI,CAACD,aAAa,CAAChF,GAAG,CAACiF,MAAM,CAAC;IAC/C;IACA,IAAIjF,GAAG,CAACmF,OAAO,EAAE;MACbnF,GAAG,CAACmF,OAAO,GAAG,IAAI,CAACD,cAAc,CAAClF,GAAG,CAACmF,OAAO,CAAC;IAClD;IACA;IACA,MAAM+F,IAAI,GAAG;MAAE,GAAGlL,GAAG;MAAEiI,EAAE,EAAEgD;IAAM,CAAC;IAClC,IAAI,CAAC,IAAI,CAACrD,kBAAkB,CAAC,CAACsD,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC9H,MAAM,EAAE;MAC/C;IACJ;IACA,IAAI,IAAI,CAACoB,gBAAgB,IACrB0G,IAAI,CAACpB,QAAQ,KAAKrJ,SAAS,IAC3ByK,IAAI,CAACnB,YAAY,KAAKtJ,SAAS,EAAE;MACjC,IAAI,CAACsI,+BAA+B,CAAC;QAAEF,MAAM,EAAE,QAAQ;QAAE9G,IAAI,EAAEmJ;MAAK,CAAC,CAAC;MACtE;IACJ;IACA,MAAMnG,OAAO,GAAG;MAAE,GAAG,IAAI,CAACA,OAAO;MAAE,cAAc,EAAE;IAAmB,CAAC;IACvE,MAAM1D,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,YAAAlD,MAAA,CAASoK,KAAK,GAAI;MAC3EnF,MAAM,EAAE,OAAO;MACff,OAAO;MACPxD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAACvH,GAAG,CAAC;MACzB+F,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM/C,cAAc,CAACC,QAAQ,EAAE,YAAY,CAAC;EAChD;EACA,MAAM8J,OAAOA,CAACF,KAAK,EAAgD;IAAA,IAA9C;MAAEG;IAAc,CAAC,GAAAjI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG;MAAEiI,aAAa,EAAE;IAAM,CAAC;IAC7DhJ,UAAU,CAAC6I,KAAK,CAAC;IACjB,IAAIjL,GAAG,GAAG,MAAM,IAAI,CAACkG,IAAI,UAAArF,MAAA,CAAUoK,KAAK,CAAE,CAAC;IAC3C,IAAIG,aAAa,IAAIpL,GAAG,CAACqL,aAAa,EAAE;MACpCrL,GAAG,GAAG,MAAM,IAAI,CAACsL,cAAc,CAACtL,GAAG,CAAC;IACxC;IACA,OAAOA,GAAG;EACd;EACA,MAAMuL,SAASA,CAAAC,KAAA,EAA+B;IAAA,IAA9B;MAAEP,KAAK;MAAEjL,GAAG;MAAEyL;IAAa,CAAC,GAAAD,KAAA;IACxC,IAAIxL,GAAG,KAAKS,SAAS,EAAE;MACnB,IAAIiL,SAAS;MACb,IAAI1L,GAAG,CAAC2L,UAAU,EAAE;QAChBD,SAAS,GAAG1L,GAAG,CAAC2L,UAAU;MAC9B,CAAC,MACI,IAAIF,WAAW,aAAXA,WAAW,eAAXA,WAAW,CAAEG,WAAW,EAAE;QAC/BF,SAAS,GAAG,CAAC,MAAM,IAAI,CAACG,WAAW,CAAC;UAAED,WAAW,EAAEH,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEG;QAAY,CAAC,CAAC,EAAE3D,EAAE;MACtF,CAAC,MACI,IAAIwD,WAAW,aAAXA,WAAW,eAAXA,WAAW,CAAEK,SAAS,EAAE;QAC7BJ,SAAS,GAAGD,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEK,SAAS;MACtC,CAAC,MACI;QACD,MAAMC,OAAO,GAAG,MAAM,IAAI,CAACF,WAAW,CAAC;UACnCD,WAAW,EAAErM,sBAAsB,CAAC,mBAAmB,CAAC,IAAI;QAChE,CAAC,CAAC;QACFmM,SAAS,GAAGK,OAAO,CAAC9D,EAAE;MAC1B;MACA,MAAM+D,QAAQ,GAAG,MAAM,IAAI,CAACC,YAAY,CAAC,CAAC;MAC1C,UAAApL,MAAA,CAAU,IAAI,CAAC+D,UAAU,CAAC,CAAC,SAAA/D,MAAA,CAAMmL,QAAQ,kBAAAnL,MAAA,CAAe6K,SAAS,SAAA7K,MAAA,CAAMb,GAAG,CAACiI,EAAE;IACjF,CAAC,MACI,IAAIgD,KAAK,KAAKxK,SAAS,EAAE;MAC1B,MAAMyL,IAAI,GAAG,MAAM,IAAI,CAACf,OAAO,CAACF,KAAK,CAAC;MACtC,IAAI,CAACiB,IAAI,CAACC,QAAQ,EAAE;QAChB,MAAM,IAAIvL,KAAK,QAAAC,MAAA,CAAQoK,KAAK,qBAAkB,CAAC;MACnD;MACA,MAAMmB,OAAO,GAAG,IAAI,CAACxH,UAAU,CAAC,CAAC;MACjC,UAAA/D,MAAA,CAAUuL,OAAO,EAAAvL,MAAA,CAAGqL,IAAI,CAACC,QAAQ;IACrC,CAAC,MACI;MACD,MAAM,IAAIvL,KAAK,CAAC,kCAAkC,CAAC;IACvD;EACJ;EACA,MAAM0K,cAAcA,CAACtL,GAAG,EAAE;IACtB,MAAMqM,SAAS,GAAG,MAAMzK,OAAO,CAAC,IAAI,CAAC0K,QAAQ,CAAC;MAAErE,EAAE,EAAEjI,GAAG,CAACqL;IAAc,CAAC,CAAC,CAAC;IACzE,MAAMkB,OAAO,GAAG,CAAC,CAAC;IAClB,MAAM3M,IAAI,GAAG,CAAC,CAAC;IACf;IACAyM,SAAS,CAACG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC;MAAA,IAAAC,eAAA,EAAAC,eAAA;MAAA,OAAK,EAAAD,eAAA,GAACF,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAE1C,YAAY,cAAA4C,eAAA,cAAAA,eAAA,GAAI,EAAE,EAAEE,aAAa,EAAAD,eAAA,GAACF,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAE3C,YAAY,cAAA6C,eAAA,cAAAA,eAAA,GAAI,EAAE,CAAC;IAAA,EAAC;IACtF,KAAK,MAAME,QAAQ,IAAIT,SAAS,EAAE;MAC9B,IAAIS,QAAQ,CAACC,aAAa,KAAK,IAAI,IAC/BD,QAAQ,CAACC,aAAa,KAAKtM,SAAS,EAAE;QACtC,MAAM,IAAIG,KAAK,cAAAC,MAAA,CAAciM,QAAQ,CAAC7E,EAAE,mBAAgB,CAAC;MAC7D;MACA,IAAI,EAAE6E,QAAQ,CAACC,aAAa,IAAIR,OAAO,CAAC,EAAE;QACtCA,OAAO,CAACO,QAAQ,CAACC,aAAa,CAAC,GAAG,EAAE;MACxC;MACAR,OAAO,CAACO,QAAQ,CAACC,aAAa,CAAC,CAAC/K,IAAI,CAAC8K,QAAQ,CAAC;MAC9ClN,IAAI,CAACkN,QAAQ,CAAC7E,EAAE,CAAC,GAAG6E,QAAQ;IAChC;IACA9M,GAAG,CAACgN,UAAU,GAAGT,OAAO,CAACvM,GAAG,CAACiI,EAAE,CAAC,IAAI,EAAE;IACtC,KAAK,MAAMgD,KAAK,IAAIsB,OAAO,EAAE;MACzB,IAAItB,KAAK,KAAKjL,GAAG,CAACiI,EAAE,EAAE;QAClBrI,IAAI,CAACqL,KAAK,CAAC,CAAC+B,UAAU,GAAGT,OAAO,CAACtB,KAAK,CAAC;MAC3C;IACJ;IACA,OAAOjL,GAAG;EACd;EACOsM,QAAQA,CAAAW,KAAA;IAAA;MAAA,IAAAC,MAAA;MAAA,IAAC;QAAEpB,SAAS;QAAEF,WAAW;QAAEuB,WAAW;QAAEC,kBAAkB;QAAEC,SAAS;QAAEC,cAAc;QAAEC,OAAO;QAAEC,KAAK;QAAEvF,EAAE;QAAEwF,KAAK;QAAE7E,MAAM;QAAElC;MAAO,CAAC,GAAAuG,KAAA;MAAA,0BAAE;QAC/I,IAAIS,UAAU,GAAG5B,SAAS;QAC1B,IAAIF,WAAW,EAAE;UACb,IAAIE,SAAS,EAAE;YACX,MAAM,IAAIlL,KAAK,CAAC,mDAAmD,CAAC;UACxE;UACA8M,UAAU,GAAG,CAAC,MAAMR,MAAI,CAACrB,WAAW,CAAC;YAAED;UAAY,CAAC,CAAC,EAAE3D,EAAE;QAC7D;QACA,MAAM1G,IAAI,GAAG;UACToM,OAAO,EAAED,UAAU,GAAG,CAACA,UAAU,CAAC,GAAG,IAAI;UACzCE,QAAQ,EAAEL,OAAO;UACjBM,iBAAiB,EAAET,kBAAkB;UACrCK,KAAK;UACL7E,MAAM;UACNkF,eAAe,EAAER,cAAc;UAC/BS,UAAU,EAAEZ,WAAW,GAAG,CAACA,WAAW,CAAC,GAAG,IAAI;UAC9CxD,UAAU,EAAE0D,SAAS,GAAGA,SAAS,CAACW,WAAW,CAAC,CAAC,GAAG,IAAI;UACtDR,KAAK;UACLvF,EAAE;UACFvB;QACJ,CAAC;QACD,WAAW,MAAM9G,IAAI,IAAIsN,MAAI,CAACjG,uBAAuB,CAAC,aAAa,EAAE1F,IAAI,CAAC,EAAE;UACxE,OAAO3B,IAAI;QACf;MACJ,CAAC;IAAA,SAAAkH,CAAA;MAAA,OAAAC,OAAA,CAAAC,MAAA,CAAAF,CAAA;IAAA;EAAA;EACD,MAAMmH,QAAQA,CAAChD,KAAK,EAAoB;IAAA,IAAlB;MAAEiD;IAAQ,CAAC,GAAA/K,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,CAAC,CAAC;IAClC,MAAM+H,IAAI,GAAG;MACTiD,MAAM,EAAElD,KAAK;MACbmD,WAAW,EAAEF,OAAO,IAAI/O,IAAI,CAACkP,EAAE,CAAC;IACpC,CAAC;IACDjM,UAAU,CAAC6I,KAAK,CAAC;IACjB,MAAM5J,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,YAAAlD,MAAA,CAASoK,KAAK,aAAU;MACjFnF,MAAM,EAAE,KAAK;MACbf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBxD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAAC2D,IAAI,CAAC;MAC1BnF,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAMrC,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACpC,IAAIrE,MAAM,KAAK,IAAI,IAAI,EAAE,aAAa,IAAIA,MAAM,CAAC,EAAE;MAC/C,MAAM,IAAIlB,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,UAAAC,MAAA,CAAU,IAAI,CAAC+D,UAAU,CAAC,CAAC,cAAA/D,MAAA,CAAWiB,MAAM,CAAC,aAAa,CAAC;EAC/D;EACA,MAAMwM,UAAUA,CAACrD,KAAK,EAAE;IACpB7I,UAAU,CAAC6I,KAAK,CAAC;IACjB,MAAM5J,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,YAAAlD,MAAA,CAASoK,KAAK,aAAU;MACjFnF,MAAM,EAAE,QAAQ;MAChBf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM/C,cAAc,CAACC,QAAQ,EAAE,aAAa,CAAC;EACjD;EACA,MAAMkN,iBAAiBA,CAACtD,KAAK,EAAE;IAC3B7I,UAAU,CAAC6I,KAAK,CAAC;IACjB,MAAM5J,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,YAAAlD,MAAA,CAASoK,KAAK,aAAU;MACjFnF,MAAM,EAAE,KAAK;MACbf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAMrC,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACpC,IAAIrE,MAAM,KAAK,IAAI,IAAI,EAAE,aAAa,IAAIA,MAAM,CAAC,EAAE;MAC/C,OAAOrB,SAAS;IACpB;IACA,UAAAI,MAAA,CAAU,IAAI,CAAC+D,UAAU,CAAC,CAAC,cAAA/D,MAAA,CAAWiB,MAAM,CAAC,aAAa,CAAC;EAC/D;EACA,MAAM0M,cAAcA,CAACC,UAAU,EAAoB;IAAA,IAAlB;MAAEC;IAAQ,CAAC,GAAAvL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,CAAC,CAAC;IAC7C,MAAMqC,WAAW,GAAG,IAAIc,eAAe,CAAC;MACpC8H,WAAW,EAAEK;IACjB,CAAC,CAAC;IACF,IAAIC,MAAM,KAAKjO,SAAS,EAAE;MACtB,KAAK,MAAMwK,KAAK,IAAIyD,MAAM,EAAE;QACxBlJ,WAAW,CAACmJ,MAAM,CAAC,IAAI,EAAE1D,KAAK,CAAC;MACnC;IACJ;IACA7I,UAAU,CAACqM,UAAU,CAAC;IACtB,MAAMpN,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,cAAAlD,MAAA,CAAW4N,UAAU,WAAA5N,MAAA,CAAQ2E,WAAW,GAAI;MACrGM,MAAM,EAAE,KAAK;MACbf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAMvE,IAAI,GAAG,MAAMyB,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IAClC,OAAOvG,IAAI;EACf;EACA,MAAMgP,uBAAuBA,CAACC,SAAS,EAAEC,WAAW,EAAE;IAClD,IAAI,CAACD,SAAS,IAAI,CAACC,WAAW,EAAE;MAC5B,MAAM,IAAIlO,KAAK,CAAC,+CAA+C,CAAC;IACpE;IACA,IAAI,CAACiO,SAAS,EAAE;MACZ,MAAME,OAAO,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC;QAAEF;MAAY,CAAC,CAAC;MACvDD,SAAS,GAAGE,OAAO,CAAC9G,EAAE;IAC1B;IACA7F,UAAU,CAACyM,SAAS,CAAC;IACrB,MAAMxN,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,gBAAAlD,MAAA,CAAagO,SAAS,aAAU;MACzF/I,MAAM,EAAE,KAAK;MACbf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM8K,WAAW,GAAG,MAAM5N,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACzC8I,WAAW,CAAClO,GAAG,MAAAF,MAAA,CAAM,IAAI,CAAC+D,UAAU,CAAC,CAAC,cAAA/D,MAAA,CAAWoO,WAAW,CAACb,WAAW,OAAI;IAC5E,OAAOa,WAAW;EACtB;EACA,MAAMC,YAAYA,CAACL,SAAS,EAAEC,WAAW,EAAE;IACvC,IAAI,CAACD,SAAS,IAAI,CAACC,WAAW,EAAE;MAC5B,MAAM,IAAIlO,KAAK,CAAC,+CAA+C,CAAC;IACpE;IACA,IAAI,CAACiO,SAAS,EAAE;MACZ,MAAME,OAAO,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC;QAAEF;MAAY,CAAC,CAAC;MACvDD,SAAS,GAAGE,OAAO,CAAC9G,EAAE;IAC1B;IACA,MAAMiD,IAAI,GAAG;MACTiE,UAAU,EAAEN;IAChB,CAAC;IACDzM,UAAU,CAACyM,SAAS,CAAC;IACrB,MAAMxN,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,gBAAAlD,MAAA,CAAagO,SAAS,aAAU;MACzF/I,MAAM,EAAE,KAAK;MACbf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBxD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAAC2D,IAAI,CAAC;MAC1BnF,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM8K,WAAW,GAAG,MAAM5N,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACzC8I,WAAW,CAAClO,GAAG,MAAAF,MAAA,CAAM,IAAI,CAAC+D,UAAU,CAAC,CAAC,cAAA/D,MAAA,CAAWoO,WAAW,CAACb,WAAW,OAAI;IAC5E,OAAOa,WAAW;EACtB;EACA,MAAMG,cAAcA,CAACP,SAAS,EAAE;IAC5BzM,UAAU,CAACyM,SAAS,CAAC;IACrB,MAAMxN,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,gBAAAlD,MAAA,CAAagO,SAAS,aAAU;MACzF/I,MAAM,EAAE,QAAQ;MAChBf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM/C,cAAc,CAACC,QAAQ,EAAE,iBAAiB,CAAC;EACrD;EACA,MAAMgO,iBAAiBA,CAACZ,UAAU,EAAE;IAChCrM,UAAU,CAACqM,UAAU,CAAC;IACtB,MAAMpN,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,cAAAlD,MAAA,CAAW4N,UAAU,gBAAa;MAC3F3I,MAAM,EAAE,KAAK;MACbf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM4K,OAAO,GAAG,MAAM1N,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACrC,OAAO4I,OAAO;EAClB;EACA,MAAMO,aAAaA,CAAAC,KAAA,EAAwH;IAAA,IAAvH;MAAE3D,WAAW;MAAE4D,WAAW,GAAG,IAAI;MAAEpP,QAAQ,GAAG,IAAI;MAAEqP,MAAM,GAAG,KAAK;MAAEC,YAAY,GAAG,IAAI;MAAEC,kBAAkB,GAAG;IAAM,CAAC,GAAAJ,KAAA;IACrI,MAAMK,OAAO,GAAGH,MAAM,oBAAoB,EAAE;IAC5C,MAAMI,QAAQ,MAAAhP,MAAA,CAAM,IAAI,CAACkD,MAAM,eAAAlD,MAAA,CAAY+O,OAAO,CAAE;IACpD,MAAMzP,KAAK,GAAGuP,YAAY,IAAI,CAAC,CAAC;IAChC,IAAItP,QAAQ,EAAE;MACVD,KAAK,CAAC,UAAU,CAAC,GAAGC,QAAQ;IAChC;IACA,MAAMmB,IAAI,GAAG;MACTuO,IAAI,EAAElE,WAAW;MACjBzL,KAAK;MACLqP;IACJ,CAAC;IACD,IAAIG,kBAAkB,KAAK,IAAI,EAAE;MAC7BpO,IAAI,CAAC,sBAAsB,CAAC,GAAGoO,kBAAkB;IACrD;IACA,MAAMtO,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,EAAEgK,QAAQ,EAAE;MACrD/J,MAAM,EAAE,MAAM;MACdf,OAAO,EAAE;QAAE,GAAG,IAAI,CAACA,OAAO;QAAE,cAAc,EAAE;MAAmB,CAAC;MAChExD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAAChG,IAAI,CAAC;MAC1BwE,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAMrC,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACpC,IAAI,CAAC9E,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIb,KAAK,6BAAAC,MAAA,CAA6B+K,WAAW,QAAA/K,MAAA,CAAKQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IACzG;IACA,OAAOG,MAAM;EACjB;EACA,MAAMiO,aAAaA,CAACjE,SAAS,EAAAkE,KAAA,EAA8F;IAAA,IAA5F;MAAEF,IAAI,GAAG,IAAI;MAAEN,WAAW,GAAG,IAAI;MAAEpP,QAAQ,GAAG,IAAI;MAAEsP,YAAY,GAAG,IAAI;MAAEO,OAAO,GAAG;IAAM,CAAC,GAAAD,KAAA;IACrH,MAAMH,QAAQ,MAAAhP,MAAA,CAAM,IAAI,CAACkD,MAAM,gBAAAlD,MAAA,CAAaiL,SAAS,CAAE;IACvD,IAAI3L,KAAK,GAAGuP,YAAY;IACxB,IAAItP,QAAQ,EAAE;MACVD,KAAK,GAAG;QAAE,IAAIA,KAAK,IAAI,CAAC,CAAC,CAAC;QAAEC;MAAS,CAAC;IAC1C;IACA,MAAMmB,IAAI,GAAG;MACTuO,IAAI;MACJ3P,KAAK;MACLqP,WAAW;MACXU,QAAQ,EAAED,OAAO,GAAG,IAAIrG,IAAI,CAACqG,OAAO,CAAC,CAACjC,WAAW,CAAC,CAAC,GAAG;IAC1D,CAAC;IACD,MAAM3M,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,EAAEgK,QAAQ,EAAE;MACrD/J,MAAM,EAAE,OAAO;MACff,OAAO,EAAE;QAAE,GAAG,IAAI,CAACA,OAAO;QAAE,cAAc,EAAE;MAAmB,CAAC;MAChExD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAAChG,IAAI,CAAC;MAC1BwE,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAMrC,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACpC,IAAI,CAAC9E,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIb,KAAK,6BAAAC,MAAA,CAA6BiL,SAAS,QAAAjL,MAAA,CAAKQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IACvG;IACA,OAAOG,MAAM;EACjB;EACA,MAAM+J,WAAWA,CAAAsE,KAAA,EAA4C;IAAA,IAA3C;MAAErE,SAAS;MAAEF,WAAW;MAAEwE;IAAc,CAAC,GAAAD,KAAA;IACvD,IAAI5K,IAAI,GAAG,WAAW;IACtB,MAAMmF,MAAM,GAAG,IAAIpE,eAAe,CAAC,CAAC;IACpC,IAAIwF,SAAS,KAAKrL,SAAS,IAAImL,WAAW,KAAKnL,SAAS,EAAE;MACtD,MAAM,IAAIG,KAAK,CAAC,wDAAwD,CAAC;IAC7E,CAAC,MACI,IAAIkL,SAAS,KAAKrL,SAAS,EAAE;MAC9B2B,UAAU,CAAC0J,SAAS,CAAC;MACrBvG,IAAI,QAAA1E,MAAA,CAAQiL,SAAS,CAAE;IAC3B,CAAC,MACI,IAAIF,WAAW,KAAKnL,SAAS,EAAE;MAChCiK,MAAM,CAACiE,MAAM,CAAC,MAAM,EAAE/C,WAAW,CAAC;IACtC,CAAC,MACI;MACD,MAAM,IAAIhL,KAAK,CAAC,uCAAuC,CAAC;IAC5D;IACA,IAAIwP,YAAY,KAAK3P,SAAS,EAAE;MAC5BiK,MAAM,CAACiE,MAAM,CAAC,eAAe,EAAEyB,YAAY,CAACzK,QAAQ,CAAC,CAAC,CAAC;IAC3D;IACA,MAAMtE,QAAQ,GAAG,MAAM,IAAI,CAAC6E,IAAI,CAACX,IAAI,EAAEmF,MAAM,CAAC;IAC9C,IAAI5I,MAAM;IACV,IAAIuO,KAAK,CAACC,OAAO,CAACjP,QAAQ,CAAC,EAAE;MACzB,IAAIA,QAAQ,CAAC+B,MAAM,KAAK,CAAC,EAAE;QACvB,MAAM,IAAIxC,KAAK,eAAAC,MAAA,CAAeiL,SAAS,aAAAjL,MAAA,CAAU+K,WAAW,gBAAa,CAAC;MAC9E;MACA9J,MAAM,GAAGT,QAAQ,CAAC,CAAC,CAAC;IACxB,CAAC,MACI;MACDS,MAAM,GAAGT,QAAQ;IACrB;IACA,OAAOS,MAAM;EACjB;EACA,MAAMmK,YAAYA,CAAA,EAAG;IACjB,IAAI,IAAI,CAACsE,SAAS,KAAK,IAAI,EAAE;MACzB,OAAO,IAAI,CAACA,SAAS;IACzB;IACA,MAAM/K,WAAW,GAAG,IAAIc,eAAe,CAAC;MAAEI,KAAK,EAAE;IAAI,CAAC,CAAC;IACvD,WAAW,MAAM8J,QAAQ,IAAI,IAAI,CAACpK,aAAa,CAAC,WAAW,EAAEZ,WAAW,CAAC,EAAE;MACvE,IAAI,CAAC+K,SAAS,GAAGC,QAAQ,CAAC,CAAC,CAAC,CAACC,SAAS;MACtC,OAAOD,QAAQ,CAAC,CAAC,CAAC,CAACC,SAAS;IAChC;IACA,MAAM,IAAI7P,KAAK,CAAC,sCAAsC,CAAC;EAC3D;EACO8P,YAAYA,CAAA;IAAA;MAAA,IAAAC,MAAA;MAAA,IAAC;QAAEC,UAAU;QAAEd,IAAI;QAAEe,YAAY;QAAElB,kBAAkB;QAAEmB,oBAAoB;QAAEC;MAAe,CAAC,GAAA5N,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,CAAC,CAAC;MAAA,0BAAE;QACnH,MAAMuH,MAAM,GAAG,IAAIpE,eAAe,CAAC,CAAC;QACpC,IAAIsK,UAAU,KAAKnQ,SAAS,EAAE;UAC1B,KAAK,MAAMqL,SAAS,IAAI8E,UAAU,EAAE;YAChClG,MAAM,CAACiE,MAAM,CAAC,IAAI,EAAE7C,SAAS,CAAC;UAClC;QACJ;QACA,IAAIgE,IAAI,KAAKrP,SAAS,EAAE;UACpBiK,MAAM,CAACiE,MAAM,CAAC,MAAM,EAAEmB,IAAI,CAAC;QAC/B;QACA,IAAIe,YAAY,KAAKpQ,SAAS,EAAE;UAC5BiK,MAAM,CAACiE,MAAM,CAAC,eAAe,EAAEkC,YAAY,CAAC;QAChD;QACA,IAAIlB,kBAAkB,KAAKlP,SAAS,EAAE;UAClCiK,MAAM,CAACiE,MAAM,CAAC,mBAAmB,EAAEgB,kBAAkB,CAAC;QAC1D,CAAC,MACI,IAAImB,oBAAoB,KAAKrQ,SAAS,EAAE;UACzC,MAAMsO,OAAO,GAAG,MAAM4B,MAAI,CAAC3B,WAAW,CAAC;YACnCF,WAAW,EAAEgC;UACjB,CAAC,CAAC;UACFpG,MAAM,CAACiE,MAAM,CAAC,mBAAmB,EAAEI,OAAO,CAAC9G,EAAE,CAAC;QAClD;QACA,IAAI8I,aAAa,KAAKtQ,SAAS,EAAE;UAC7BiK,MAAM,CAACiE,MAAM,CAAC,gBAAgB,EAAEoC,aAAa,CAACpL,QAAQ,CAAC,CAAC,CAAC;QAC7D;QACA,WAAW,MAAM6K,QAAQ,IAAIG,MAAI,CAACvK,aAAa,CAAC,WAAW,EAAEsE,MAAM,CAAC,EAAE;UAClE,OAAO8F,QAAQ;QACnB;MACJ,CAAC;IAAA,SAAA1J,CAAA;MAAA,OAAAC,OAAA,CAAAC,MAAA,CAAAF,CAAA;IAAA;EAAA;EACD,MAAMkK,aAAaA,CAAAC,KAAA,EAA8B;IAAA,IAA7B;MAAEnF,SAAS;MAAEF;IAAa,CAAC,GAAAqF,KAAA;IAC3C,IAAIvD,UAAU;IACd,IAAI5B,SAAS,KAAKrL,SAAS,IAAImL,WAAW,KAAKnL,SAAS,EAAE;MACtD,MAAM,IAAIG,KAAK,CAAC,uCAAuC,CAAC;IAC5D,CAAC,MACI,IAAIkL,SAAS,KAAKrL,SAAS,IAAImL,WAAW,KAAKnL,SAAS,EAAE;MAC3D,MAAM,IAAIG,KAAK,CAAC,wDAAwD,CAAC;IAC7E,CAAC,MACI,IAAIkL,SAAS,KAAKrL,SAAS,EAAE;MAC9BiN,UAAU,GAAG,CAAC,MAAM,IAAI,CAAC7B,WAAW,CAAC;QAAED;MAAY,CAAC,CAAC,EAAE3D,EAAE;IAC7D,CAAC,MACI;MACDyF,UAAU,GAAG5B,SAAS;IAC1B;IACA1J,UAAU,CAACsL,UAAU,CAAC;IACtB,MAAMrM,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,gBAAAlD,MAAA,CAAa6M,UAAU,GAAI;MACpF5H,MAAM,EAAE,QAAQ;MAChBf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM/C,cAAc,CAACC,QAAQ,oBAAAR,MAAA,CAAoB6M,UAAU,QAAA7M,MAAA,CAAK+K,WAAW,MAAG,CAAC;EACnF;EACA,MAAMsF,SAASA,CAAAC,KAAA,EAA6E;IAAA,IAA5E;MAAEC,OAAO;MAAEC,QAAQ;MAAEC,SAAS;MAAEC,UAAU;MAAE/B,WAAW;MAAEgC,QAAQ;MAAE1B;IAAM,CAAC,GAAAqB,KAAA;IACtF,MAAMpQ,GAAG,MAAAF,MAAA,CAAM,IAAI,CAACkD,MAAM,qBAAkB;IAC5C,MAAM0N,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;IAC/BD,QAAQ,CAAC9C,MAAM,CAAC,MAAM,EAAEyC,OAAO,EAAEC,QAAQ,CAAC;IAC1CC,SAAS,CAACK,OAAO,CAAEC,GAAG,IAAK;MACvBH,QAAQ,CAAC9C,MAAM,CAAC,YAAY,EAAEiD,GAAG,CAAC;IACtC,CAAC,CAAC;IACFL,UAAU,CAACI,OAAO,CAAEC,GAAG,IAAK;MACxBH,QAAQ,CAAC9C,MAAM,CAAC,aAAa,EAAEiD,GAAG,CAAC;IACvC,CAAC,CAAC;IACF,IAAIpC,WAAW,EAAE;MACbiC,QAAQ,CAAC9C,MAAM,CAAC,aAAa,EAAEa,WAAW,CAAC;IAC/C;IACA,IAAIgC,QAAQ,EAAE;MACVC,QAAQ,CAAC9C,MAAM,CAAC,WAAW,EAAE6C,QAAQ,CAAC;IAC1C;IACA,IAAI1B,IAAI,EAAE;MACN2B,QAAQ,CAAC9C,MAAM,CAAC,MAAM,EAAEmB,IAAI,CAAC;IACjC;IACA,MAAMzO,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,EAAE9E,GAAG,EAAE;MAChD+E,MAAM,EAAE,MAAM;MACdf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBxD,IAAI,EAAEkQ,QAAQ;MACd1L,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,IAAI,CAAC9C,QAAQ,CAACI,EAAE,EAAE;MACd,MAAMK,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;MACpC,IAAIrE,MAAM,CAAC+P,MAAM,IAAI/P,MAAM,CAAC+P,MAAM,CAAChN,QAAQ,CAAC,gBAAgB,CAAC,EAAE;QAC3D,MAAM,IAAIjE,KAAK,YAAAC,MAAA,CAAYwQ,QAAQ,oBAAiB,CAAC;MACzD;MACA,MAAM,IAAIzQ,KAAK,0BAAAC,MAAA,CAA0BQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IACtF;IACA,MAAMG,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACpC,OAAOrE,MAAM;EACjB;EACA,MAAMgQ,aAAaA,CAAChC,IAAI,EAAmC;IAAA,IAAjC;MAAEN,WAAW;MAAEgC;IAAU,CAAC,GAAArO,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,CAAC,CAAC;IACrD,MAAM5B,IAAI,GAAG;MACTuO,IAAI;MACJN;IACJ,CAAC;IACD,IAAIgC,QAAQ,EAAE;MACVjQ,IAAI,CAACwQ,SAAS,GAAGP,QAAQ;IAC7B;IACA,MAAMnQ,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,gBAAa;MACtE+B,MAAM,EAAE,MAAM;MACdf,OAAO,EAAE;QAAE,GAAG,IAAI,CAACA,OAAO;QAAE,cAAc,EAAE;MAAmB,CAAC;MAChExD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAAChG,IAAI,CAAC;MAC1BwE,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,IAAI,CAAC9C,QAAQ,CAACI,EAAE,EAAE;MACd,MAAMK,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;MACpC,IAAIrE,MAAM,CAAC+P,MAAM,IAAI/P,MAAM,CAAC+P,MAAM,CAAChN,QAAQ,CAAC,gBAAgB,CAAC,EAAE;QAC3D,MAAM,IAAIjE,KAAK,YAAAC,MAAA,CAAYiP,IAAI,oBAAiB,CAAC;MACrD;MACA,MAAM,IAAIlP,KAAK,6BAAAC,MAAA,CAA6BQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IACzF;IACA,MAAMG,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACpC,OAAOrE,MAAM;EACjB;EACA,MAAMkN,WAAWA,CAAAgD,KAAA,EAA8B;IAAA,IAA7B;MAAEnD,SAAS;MAAEC;IAAa,CAAC,GAAAkD,KAAA;IACzC,IAAIzM,IAAI,GAAG,WAAW;IACtB;IACA,MAAMmF,MAAM,GAAG,IAAIpE,eAAe,CAAC;MAAEI,KAAK,EAAE;IAAI,CAAC,CAAC;IAClD,IAAImI,SAAS,KAAKpO,SAAS,IAAIqO,WAAW,KAAKrO,SAAS,EAAE;MACtD,MAAM,IAAIG,KAAK,CAAC,wDAAwD,CAAC;IAC7E,CAAC,MACI,IAAIiO,SAAS,KAAKpO,SAAS,EAAE;MAC9B2B,UAAU,CAACyM,SAAS,CAAC;MACrBtJ,IAAI,QAAA1E,MAAA,CAAQgO,SAAS,CAAE;IAC3B,CAAC,MACI,IAAIC,WAAW,KAAKrO,SAAS,EAAE;MAChCiK,MAAM,CAACiE,MAAM,CAAC,MAAM,EAAEG,WAAW,CAAC;IACtC,CAAC,MACI;MACD,MAAM,IAAIlO,KAAK,CAAC,uCAAuC,CAAC;IAC5D;IACA,MAAMS,QAAQ,GAAG,MAAM,IAAI,CAAC6E,IAAI,CAACX,IAAI,EAAEmF,MAAM,CAAC;IAC9C,IAAI5I,MAAM;IACV,IAAIuO,KAAK,CAACC,OAAO,CAACjP,QAAQ,CAAC,EAAE;MACzB,IAAIA,QAAQ,CAAC+B,MAAM,KAAK,CAAC,EAAE;QACvB,MAAM,IAAIxC,KAAK,eAAAC,MAAA,CAAegO,SAAS,aAAAhO,MAAA,CAAUiO,WAAW,gBAAa,CAAC;MAC9E;MACAhN,MAAM,GAAGT,QAAQ,CAAC,CAAC,CAAC;IACxB,CAAC,MACI;MACDS,MAAM,GAAGT,QAAQ;IACrB;IACA,OAAOS,MAAM;EACjB;EACA,MAAMmQ,2BAA2BA,CAAAC,MAAA,EAA8B;IAAA,IAA7B;MAAErD,SAAS;MAAEC;IAAa,CAAC,GAAAoD,MAAA;IACzD,MAAM3M,IAAI,GAAG,WAAW;IACxB,IAAIsJ,SAAS,KAAKpO,SAAS,EAAE;MACzB;IAAA,CACH,MACI,IAAIqO,WAAW,KAAKrO,SAAS,EAAE;MAChCoO,SAAS,GAAG,CAAC,MAAM,IAAI,CAACG,WAAW,CAAC;QAAEF;MAAY,CAAC,CAAC,EAAE7G,EAAE;IAC5D,CAAC,MACI;MACD,MAAM,IAAIrH,KAAK,CAAC,uCAAuC,CAAC;IAC5D;IACA,MAAMS,QAAQ,GAAG,MAAM,IAAI,CAACiE,YAAY,IAAAzE,MAAA,CAAI0E,IAAI,OAAA1E,MAAA,CAAIgO,SAAS,eAAY,CAAC;IAC1E,MAAMsD,WAAW,GAAG,MAAM9Q,QAAQ,CAACG,IAAI,CAAC,CAAC;IACzC,MAAMuN,OAAO,GAAGoD,WAAW,CACtBhQ,IAAI,CAAC,CAAC,CACNhB,KAAK,CAAC,IAAI,CAAC,CACXpB,GAAG,CAAEqS,IAAI,IAAK9K,IAAI,CAAC+K,KAAK,CAACD,IAAI,CAAC,CAAC;IACpC,OAAOrD,OAAO;EAClB;EACOuD,YAAYA,CAAA;IAAA;MAAA,IAAAC,MAAA;MAAA,IAAC;QAAE7L,KAAK,GAAG,GAAG;QAAEH,MAAM,GAAG,CAAC;QAAEiM,UAAU;QAAE1D,WAAW;QAAE2D;MAAqB,CAAC,GAAAtP,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,CAAC,CAAC;MAAA,0BAAE;QACjG,MAAMoC,IAAI,GAAG,WAAW;QACxB,MAAMmF,MAAM,GAAG,IAAIpE,eAAe,CAAC;UAC/BI,KAAK,EAAEA,KAAK,CAACf,QAAQ,CAAC,CAAC;UACvBY,MAAM,EAAEA,MAAM,CAACZ,QAAQ,CAAC;QAC5B,CAAC,CAAC;QACF,IAAI6M,UAAU,KAAK/R,SAAS,EAAE;UAC1B,KAAK,MAAMiS,GAAG,IAAIF,UAAU,EAAE;YAC1B9H,MAAM,CAACiE,MAAM,CAAC,IAAI,EAAE+D,GAAG,CAAC;UAC5B;QACJ;QACA,IAAI5D,WAAW,KAAKrO,SAAS,EAAE;UAC3BiK,MAAM,CAACiE,MAAM,CAAC,MAAM,EAAEG,WAAW,CAAC;QACtC;QACA,IAAI2D,mBAAmB,KAAKhS,SAAS,EAAE;UACnCiK,MAAM,CAACiE,MAAM,CAAC,eAAe,EAAE8D,mBAAmB,CAAC;QACvD;QACA,WAAW,MAAME,QAAQ,IAAIJ,MAAI,CAACnM,aAAa,CAACb,IAAI,EAAEmF,MAAM,CAAC,EAAE;UAC3D,OAAOiI,QAAQ;QACnB;MACJ,CAAC;IAAA,SAAA7L,CAAA;MAAA,OAAAC,OAAA,CAAAC,MAAA,CAAAF,CAAA;IAAA;EAAA;EACD,MAAM8L,aAAaA,CAAAC,MAAA,EAA8B;IAAA,IAA7B;MAAEhE,SAAS;MAAEC;IAAa,CAAC,GAAA+D,MAAA;IAC3C,IAAItN,IAAI,GAAG,WAAW;IACtB,IAAIuN,UAAU,GAAGjE,SAAS;IAC1B,IAAIA,SAAS,KAAKpO,SAAS,IAAIqO,WAAW,KAAKrO,SAAS,EAAE;MACtD,MAAM,IAAIG,KAAK,CAAC,wDAAwD,CAAC;IAC7E,CAAC,MACI,IAAIkO,WAAW,KAAKrO,SAAS,EAAE;MAChC,MAAMsO,OAAO,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC;QAAEF;MAAY,CAAC,CAAC;MACvDgE,UAAU,GAAG/D,OAAO,CAAC9G,EAAE;IAC3B;IACA,IAAI6K,UAAU,KAAKrS,SAAS,EAAE;MAC1B2B,UAAU,CAAC0Q,UAAU,CAAC;MACtBvN,IAAI,QAAA1E,MAAA,CAAQiS,UAAU,CAAE;IAC5B,CAAC,MACI;MACD,MAAM,IAAIlS,KAAK,CAAC,uCAAuC,CAAC;IAC5D;IACA,MAAMS,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,EAAE,IAAI,CAAC9B,MAAM,GAAGwB,IAAI,EAAE;MAC/DO,MAAM,EAAE,QAAQ;MAChBf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,IAAI,CAAC9C,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIb,KAAK,qBAAAC,MAAA,CAAqB0E,IAAI,QAAA1E,MAAA,CAAKQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IAC1F;IACA,MAAMN,QAAQ,CAAC8E,IAAI,CAAC,CAAC;EACzB;EACA,MAAM4M,aAAaA,CAAC9N,MAAM,EAAEE,OAAO,EAAA6N,MAAA,EAAoD;IAAA,IAAlD;MAAEnE,SAAS;MAAEC,WAAW;MAAEmE,SAAS;MAAEC;IAAU,CAAC,GAAAF,MAAA;IACjF,IAAIF,UAAU,GAAGjE,SAAS;IAC1B,IAAIiE,UAAU,KAAKrS,SAAS,IAAIqO,WAAW,KAAKrO,SAAS,EAAE;MACvD,MAAM,IAAIG,KAAK,CAAC,8CAA8C,CAAC;IACnE,CAAC,MACI,IAAIkS,UAAU,KAAKrS,SAAS,IAAIqO,WAAW,KAAKrO,SAAS,EAAE;MAC5D,MAAM,IAAIG,KAAK,CAAC,wDAAwD,CAAC;IAC7E,CAAC,MACI,IAAIkS,UAAU,KAAKrS,SAAS,EAAE;MAC/B,MAAMsO,OAAO,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC;QAAEF;MAAY,CAAC,CAAC;MACvDgE,UAAU,GAAG/D,OAAO,CAAC9G,EAAE;IAC3B;IACA,MAAMkL,UAAU,GAAGF,SAAS,IAAI,IAAIrJ,IAAI,CAAC,CAAC;IAC1C,MAAMsB,IAAI,GAAG;MACTiE,UAAU,EAAE2D,UAAU;MACtB7N,MAAM;MACNE,OAAO;MACPiO,UAAU,EAAED,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEnF,WAAW,CAAC,CAAC;MACrC/F,EAAE,EAAEiL;IACR,CAAC;IACD,MAAM7R,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,gBAAa;MACtE+B,MAAM,EAAE,MAAM;MACdf,OAAO,EAAE;QAAE,GAAG,IAAI,CAACA,OAAO;QAAE,cAAc,EAAE;MAAmB,CAAC;MAChExD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAAC2D,IAAI,CAAC;MAC1BnF,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,IAAI,CAAC9C,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIb,KAAK,8BAAAC,MAAA,CAA8BQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IAC1F;IACA,MAAMG,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACpC,OAAOrE,MAAM;EACjB;EACA,MAAMuR,cAAcA,CAACC,KAAK,EAAE;IACxB,MAAM;MAAErO,MAAM;MAAEE,OAAO;MAAEoO,YAAY;MAAEC,UAAU;MAAE3E,SAAS;MAAEC;IAAa,CAAC,GAAGwE,KAAK;IACpF,IAAIR,UAAU,GAAGjE,SAAS;IAC1B,IAAIiE,UAAU,KAAKrS,SAAS,IAAIqO,WAAW,KAAKrO,SAAS,EAAE;MACvD,MAAM,IAAIG,KAAK,CAAC,8CAA8C,CAAC;IACnE,CAAC,MACI,IAAIkS,UAAU,KAAKrS,SAAS,IAAIqO,WAAW,KAAKrO,SAAS,EAAE;MAC5D,MAAM,IAAIG,KAAK,CAAC,wDAAwD,CAAC;IAC7E,CAAC,MACI,IAAIkS,UAAU,KAAKrS,SAAS,EAAE;MAC/B,MAAMsO,OAAO,GAAG,MAAM,IAAI,CAACC,WAAW,CAAC;QAAEF;MAAY,CAAC,CAAC;MACvDgE,UAAU,GAAG/D,OAAO,CAAC9G,EAAE;IAC3B;IACA,MAAMwL,iBAAiB,GAAGxO,MAAM,CAAClF,GAAG,CAAC,CAAC2T,KAAK,EAAEC,GAAG,KAAK;MACjD,OAAO;QACHxE,UAAU,EAAE2D,UAAU;QACtB7N,MAAM,EAAEyO,KAAK;QACbvO,OAAO,EAAEA,OAAO,GAAGA,OAAO,CAACwO,GAAG,CAAC,GAAGlT,SAAS;QAC3CwH,EAAE,EAAEuL,UAAU,GAAGA,UAAU,CAACG,GAAG,CAAC,GAAGlT,SAAS;QAC5CmT,aAAa,EAAEL,YAAY,GAAGA,YAAY,CAACI,GAAG,CAAC,GAAGlT;MACtD,CAAC;IACL,CAAC,CAAC;IACF,MAAMY,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,qBAAkB;MAC3E+B,MAAM,EAAE,MAAM;MACdf,OAAO,EAAE;QAAE,GAAG,IAAI,CAACA,OAAO;QAAE,cAAc,EAAE;MAAmB,CAAC;MAChExD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAACkM,iBAAiB,CAAC;MACvC1N,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,IAAI,CAAC9C,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIb,KAAK,+BAAAC,MAAA,CAA+BQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IAC3F;IACA,MAAMG,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACpC,OAAOrE,MAAM;EACjB;EACA,MAAM+R,gBAAgBA,CAACH,KAAK,EAAEI,UAAU,EAAEC,OAAO,EAAE;IAC/C,OAAO,IAAI,CAAChB,aAAa,CAAC;MAAEW;IAAM,CAAC,EAAE;MAAEM,MAAM,EAAEF;IAAW,CAAC,EAAEC,OAAO,CAAC;EACzE;EACA,MAAME,iBAAiBA,CAACP,KAAK,EAAEQ,WAAW,EAAEH,OAAO,EAAE;IACjD,MAAMI,UAAU,GAAGT,KAAK,CAAC3T,GAAG,CAAEqU,OAAO,IAAK;MACtC,IAAI9U,kBAAkB,CAAC8U,OAAO,CAAC,EAAE;QAC7B,OAAO/U,gCAAgC,CAAC+U,OAAO,CAAC;MACpD;MACA,OAAOA,OAAO;IAClB,CAAC,CAAC;IACF,MAAMC,WAAW,GAAG/U,kBAAkB,CAAC4U,WAAW,CAAC,GAC7C7U,gCAAgC,CAAC6U,WAAW,CAAC,GAC7CA,WAAW;IACjB,OAAO,IAAI,CAACnB,aAAa,CAAC;MAAEW,KAAK,EAAES;IAAW,CAAC,EAAE;MAAEH,MAAM,EAAEK;IAAY,CAAC,EAAEN,OAAO,CAAC;EACtF;EACA,MAAMO,WAAWA,CAACpB,SAAS,EAAE;IACzB9Q,UAAU,CAAC8Q,SAAS,CAAC;IACrB,MAAM3N,IAAI,gBAAA1E,MAAA,CAAgBqS,SAAS,CAAE;IACrC,OAAO,MAAM,IAAI,CAAChN,IAAI,CAACX,IAAI,CAAC;EAChC;EACOgP,YAAYA,CAAA;IAAA;MAAA,IAAAC,MAAA;MAAA,IAAC;QAAE3F,SAAS;QAAEC,WAAW;QAAE0E;MAAY,CAAC,GAAArQ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,CAAC,CAAC;MAAA,0BAAE;QAC9D,IAAI2P,UAAU;QACd,IAAIjE,SAAS,KAAKpO,SAAS,IAAIqO,WAAW,KAAKrO,SAAS,EAAE;UACtD,MAAM,IAAIG,KAAK,CAAC,wDAAwD,CAAC;QAC7E,CAAC,MACI,IAAIiO,SAAS,KAAKpO,SAAS,EAAE;UAC9BqS,UAAU,GAAGjE,SAAS;QAC1B,CAAC,MACI,IAAIC,WAAW,KAAKrO,SAAS,EAAE;UAChC,MAAMsO,OAAO,GAAG,MAAMyF,MAAI,CAACxF,WAAW,CAAC;YAAEF;UAAY,CAAC,CAAC;UACvDgE,UAAU,GAAG/D,OAAO,CAAC9G,EAAE;QAC3B,CAAC,MACI;UACD,MAAM,IAAIrH,KAAK,CAAC,yCAAyC,CAAC;QAC9D;QACA,MAAM8J,MAAM,GAAG,IAAIpE,eAAe,CAAC;UAAEyI,OAAO,EAAE+D;QAAW,CAAC,CAAC;QAC3D,IAAIU,UAAU,KAAK/S,SAAS,EAAE;UAC1B,KAAK,MAAMiS,GAAG,IAAIc,UAAU,EAAE;YAC1B9I,MAAM,CAACiE,MAAM,CAAC,IAAI,EAAE+D,GAAG,CAAC;UAC5B;QACJ;QACA,WAAW,MAAM+B,QAAQ,IAAID,MAAI,CAACpO,aAAa,CAAC,WAAW,EAAEsE,MAAM,CAAC,EAAE;UAClE,OAAO+J,QAAQ;QACnB;MACJ,CAAC;IAAA,SAAA3N,CAAA;MAAA,OAAAC,OAAA,CAAAC,MAAA,CAAAF,CAAA;IAAA;EAAA;EACD,MAAM4N,aAAaA,CAACxB,SAAS,EAAE;IAC3B9Q,UAAU,CAAC8Q,SAAS,CAAC;IACrB,MAAM3N,IAAI,gBAAA1E,MAAA,CAAgBqS,SAAS,CAAE;IACrC,MAAM7R,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,EAAE,IAAI,CAAC9B,MAAM,GAAGwB,IAAI,EAAE;MAC/DO,MAAM,EAAE,QAAQ;MAChBf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,IAAI,CAAC9C,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIb,KAAK,qBAAAC,MAAA,CAAqB0E,IAAI,QAAA1E,MAAA,CAAKQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IAC1F;IACA,MAAMN,QAAQ,CAAC8E,IAAI,CAAC,CAAC;EACzB;EACA,MAAMwO,aAAaA,CAACzB,SAAS,EAAE3I,MAAM,EAAE;IACnCnI,UAAU,CAAC8Q,SAAS,CAAC;IACrB,MAAM7R,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,gBAAAlD,MAAA,CAAaqS,SAAS,GAAI;MACnFpN,MAAM,EAAE,OAAO;MACff,OAAO,EAAE;QAAE,GAAG,IAAI,CAACA,OAAO;QAAE,cAAc,EAAE;MAAmB,CAAC;MAChExD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAACgD,MAAM,CAAC;MAC5BxE,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,IAAI,CAAC9C,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIb,KAAK,6BAAAC,MAAA,CAA6BqS,SAAS,QAAArS,MAAA,CAAKQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IACvG;IACA,MAAMG,MAAM,GAAG,MAAMT,QAAQ,CAAC8E,IAAI,CAAC,CAAC;IACpC,OAAOrE,MAAM;EACjB;EACA,MAAM8S,WAAWA,CAAC5U,GAAG,EAAE6U,SAAS,EAA+E;IAAA,IAAAC,qBAAA;IAAA,IAA7E;MAAEC,UAAU;MAAE3J,aAAa;MAAE4J;IAAkB,CAAC,GAAA7R,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG;MAAEiI,aAAa,EAAE;IAAM,CAAC;IACzG,IAAIc,IAAI;IACR,IAAI,OAAOlM,GAAG,KAAK,QAAQ,EAAE;MACzBkM,IAAI,GAAG,MAAM,IAAI,CAACf,OAAO,CAACnL,GAAG,EAAE;QAAEoL;MAAc,CAAC,CAAC;IACrD,CAAC,MACI,IAAI,OAAOpL,GAAG,KAAK,QAAQ,IAAI,IAAI,IAAIA,GAAG,EAAE;MAC7CkM,IAAI,GAAGlM,GAAG;IACd,CAAC,MACI;MACD,MAAM,IAAIY,KAAK,sBAAAC,MAAA,CAAsB,OAAOb,GAAG,CAAE,CAAC;IACtD;IACA,IAAIkM,IAAI,CAAC+I,oBAAoB,KAAK,IAAI,IAClC/I,IAAI,CAAC+I,oBAAoB,KAAKxU,SAAS,EAAE;MACzCuU,gBAAgB,GAAG,MAAM,IAAI,CAACV,WAAW,CAACpI,IAAI,CAAC+I,oBAAoB,CAAC;IACxE;IACA,MAAMC,cAAc,GAAG,MAAML,SAAS,CAACD,WAAW,CAAC1I,IAAI,EAAE8I,gBAAgB,CAAC;IAC1E,IAAIG,WAAW,GAAGJ,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAI,CAAC,CAAC;IAClC,IAAIG,cAAc,CAACE,aAAa,EAAE;MAC9BD,WAAW,GAAG;QAAE,GAAGA,WAAW;QAAE,GAAGD,cAAc,CAACE;MAAc,CAAC;IACrE;IACA,MAAMnK,KAAK,IAAA6J,qBAAA,GAAGI,cAAc,CAACG,WAAW,cAAAP,qBAAA,cAAAA,qBAAA,GAAI5I,IAAI,CAACjE,EAAE;IACnD,OAAO,MAAM,IAAI,CAACqN,cAAc,CAACrK,KAAK,EAAEiK,cAAc,CAACtD,GAAG,EAAE;MACxD2D,KAAK,EAAEL,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEK,KAAK;MAC5B7R,KAAK,EAAEwR,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAExR,KAAK;MAC5B8R,OAAO,EAAEN,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEM,OAAO;MAChCC,UAAU,EAAEP,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAEO,UAAU;MACtCV,UAAU,EAAEI,WAAW;MACvBO,kBAAkB,EAAE,OAAO;MAC3BC,WAAW,EAAET,cAAc,aAAdA,cAAc,uBAAdA,cAAc,CAAES;IACjC,CAAC,CAAC;EACN;EACA,MAAML,cAAcA,CAACrK,KAAK,EAAE2G,GAAG,EAAAgE,MAAA,EAA0H;IAAA,IAAAC,qBAAA;IAAA,IAAxH;MAAEN,KAAK;MAAE7R,KAAK;MAAE+R,UAAU;MAAED,OAAO;MAAET,UAAU;MAAEW,kBAAkB,GAAG,KAAK;MAAEC,WAAW;MAAEG,UAAU;MAAEC,KAAK,GAAG;IAAO,CAAC,GAAAH,MAAA;IACnJ,MAAMI,eAAe,GAAG;MACpBC,IAAI,EAAEP,kBAAkB,aAAlBA,kBAAkB,cAAlBA,kBAAkB,GAAI,KAAK;MACjCtV,QAAQ,EAAE2U,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAI,CAAC;IAC7B,CAAC;IACD,IAAIY,WAAW,KAAKlV,SAAS,IACzB,CAAAuV,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAE5V,QAAQ,MAAKK,SAAS,IACvC,CAACuV,eAAe,CAAC5V,QAAQ,CAAC,OAAO,CAAC,EAAE;MACpC4V,eAAe,CAAC5V,QAAQ,CAAC,OAAO,CAAC,GAAG;QAAE+N,MAAM,EAAEwH;MAAY,CAAC;IAC/D;IACA,IAAI,CAAAK,eAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAE5V,QAAQ,MAAKK,SAAS,IACvC,EAAAoV,qBAAA,GAAAG,eAAe,CAAC5V,QAAQ,CAAC,OAAO,CAAC,cAAAyV,qBAAA,uBAAjCA,qBAAA,CAAmC1H,MAAM,MAAK1N,SAAS,EAAE;MACzD2B,UAAU,CAAC4T,eAAe,CAAC5V,QAAQ,CAAC,OAAO,CAAC,CAAC+N,MAAM,CAAC;IACxD;IACA,MAAM+H,QAAQ,GAAG;MACbjO,EAAE,EAAE6N,UAAU,aAAVA,UAAU,cAAVA,UAAU,GAAI3W,IAAI,CAACkP,EAAE,CAAC,CAAC;MAC3BF,MAAM,EAAElD,KAAK;MACb2G,GAAG;MACH2D,KAAK;MACL7R,KAAK;MACL+R,UAAU;MACVD,OAAO;MACPQ,eAAe,EAAEA;IACrB,CAAC;IACD,MAAMjV,GAAG,GAAG,GAAAF,MAAA,CAAG,IAAI,CAACkD,MAAM,kBAAegS,KAAK,GAAG,QAAQ,GAAG,EAAE,CAAC;IAC/D,MAAM1U,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,EAAE9E,GAAG,EAAE;MAChD+E,MAAM,EAAE,MAAM;MACdf,OAAO,EAAE;QAAE,GAAG,IAAI,CAACA,OAAO;QAAE,cAAc,EAAE;MAAmB,CAAC;MAChExD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAAC2O,QAAQ,CAAC;MAC9BnQ,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM/C,cAAc,CAACC,QAAQ,EAAE,iBAAiB,CAAC;IACjD,OAAO6U,QAAQ;EACnB;EACA,MAAMC,cAAcA,CAACL,UAAU,EAAAM,MAAA,EAA0C;IAAA,IAAxC;MAAEb,KAAK;MAAE7R,KAAK;MAAE+R,UAAU;MAAED;IAAS,CAAC,GAAAY,MAAA;IACnE,MAAMC,cAAc,GAAG,CAAC,CAAC;IACzB,IAAId,KAAK,KAAK9U,SAAS,IAAI8U,KAAK,KAAK,IAAI,EAAE;MACvCc,cAAc,CAAC,OAAO,CAAC,GAAGd,KAAK;IACnC;IACA,IAAI7R,KAAK,KAAKjD,SAAS,IAAIiD,KAAK,KAAK,IAAI,EAAE;MACvC2S,cAAc,CAAC,OAAO,CAAC,GAAG3S,KAAK;IACnC;IACA,IAAI+R,UAAU,KAAKhV,SAAS,IAAIgV,UAAU,KAAK,IAAI,EAAE;MACjDY,cAAc,CAAC,YAAY,CAAC,GAAGZ,UAAU;IAC7C;IACA,IAAID,OAAO,KAAK/U,SAAS,IAAI+U,OAAO,KAAK,IAAI,EAAE;MAC3Ca,cAAc,CAAC,SAAS,CAAC,GAAGb,OAAO;IACvC;IACApT,UAAU,CAAC0T,UAAU,CAAC;IACtB,MAAMzU,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,KAAAhF,MAAA,CAAK,IAAI,CAACkD,MAAM,gBAAAlD,MAAA,CAAaiV,UAAU,GAAI;MACpFhQ,MAAM,EAAE,OAAO;MACff,OAAO,EAAE;QAAE,GAAG,IAAI,CAACA,OAAO;QAAE,cAAc,EAAE;MAAmB,CAAC;MAChExD,IAAI,EAAE+F,IAAI,CAACC,SAAS,CAAC8O,cAAc,CAAC;MACpCtQ,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,MAAM/C,cAAc,CAACC,QAAQ,EAAE,iBAAiB,CAAC;EACrD;EACA,MAAMiV,YAAYA,CAACR,UAAU,EAAE;IAC3B1T,UAAU,CAAC0T,UAAU,CAAC;IACtB,MAAMvQ,IAAI,gBAAA1E,MAAA,CAAgBiV,UAAU,CAAE;IACtC,MAAMzU,QAAQ,GAAG,MAAM,IAAI,CAAC6E,IAAI,CAACX,IAAI,CAAC;IACtC,OAAOlE,QAAQ;EACnB;EACA,MAAMkV,cAAcA,CAACT,UAAU,EAAE;IAC7B1T,UAAU,CAAC0T,UAAU,CAAC;IACtB,MAAMvQ,IAAI,gBAAA1E,MAAA,CAAgBiV,UAAU,CAAE;IACtC,MAAMzU,QAAQ,GAAG,MAAM,IAAI,CAAC+C,MAAM,CAACwB,IAAI,CAACC,KAAK,EAAE,IAAI,CAAC9B,MAAM,GAAGwB,IAAI,EAAE;MAC/DO,MAAM,EAAE,QAAQ;MAChBf,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBgB,MAAM,EAAEC,WAAW,CAACC,OAAO,CAAC,IAAI,CAAC9B,UAAU;IAC/C,CAAC,CAAC;IACF,IAAI,CAAC9C,QAAQ,CAACI,EAAE,EAAE;MACd,MAAM,IAAIb,KAAK,qBAAAC,MAAA,CAAqB0E,IAAI,QAAA1E,MAAA,CAAKQ,QAAQ,CAACK,MAAM,OAAAb,MAAA,CAAIQ,QAAQ,CAACM,UAAU,CAAE,CAAC;IAC1F;IACA,MAAMN,QAAQ,CAAC8E,IAAI,CAAC,CAAC;EACzB;EACOqQ,YAAYA,CAAA;IAAA;MAAA,IAAAC,MAAA;MAAA,IAAC;QAAE/H,MAAM;QAAEgI,YAAY;QAAEC;MAAqB,CAAC,GAAAxT,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA1C,SAAA,GAAA0C,SAAA,MAAG,CAAC,CAAC;MAAA,0BAAE;QACrE,MAAMqC,WAAW,GAAG,IAAIc,eAAe,CAAC,CAAC;QACzC,IAAIoI,MAAM,EAAE;UACRlJ,WAAW,CAACmJ,MAAM,CAAC,KAAK,EAAED,MAAM,CAACkI,IAAI,CAAC,GAAG,CAAC,CAAC;QAC/C;QACA,IAAIF,YAAY,EAAE;UACd,KAAK,MAAM9E,GAAG,IAAI8E,YAAY,EAAE;YAC5BlR,WAAW,CAACmJ,MAAM,CAAC,KAAK,EAAEiD,GAAG,CAAC;UAClC;QACJ;QACA,IAAI+E,mBAAmB,EAAE;UACrB,KAAK,MAAMV,IAAI,IAAIU,mBAAmB,EAAE;YACpCnR,WAAW,CAACmJ,MAAM,CAAC,QAAQ,EAAEsH,IAAI,CAAC;UACtC;QACJ;QACA,WAAW,MAAMY,SAAS,IAAIJ,MAAI,CAACrQ,aAAa,CAAC,WAAW,EAAEZ,WAAW,CAAC,EAAE;UACxE,OAAOqR,SAAS;QACpB;MACJ,CAAC;IAAA,SAAA/P,CAAA;MAAA,OAAAC,OAAA,CAAAC,MAAA,CAAAF,CAAA;IAAA;EAAA;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}