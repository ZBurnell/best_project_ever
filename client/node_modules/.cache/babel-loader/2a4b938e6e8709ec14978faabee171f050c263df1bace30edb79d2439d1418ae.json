{"ast":null,"code":"export class BaseMemory {}\nconst getValue = (values, key) => {\n  if (key !== undefined) {\n    return values[key];\n  }\n  const keys = Object.keys(values);\n  if (keys.length === 1) {\n    return values[keys[0]];\n  }\n};\n/**\n * This function is used by memory classes to select the input value\n * to use for the memory. If there is only one input value, it is used.\n * If there are multiple input values, the inputKey must be specified.\n */\nexport const getInputValue = (inputValues, inputKey) => {\n  const value = getValue(inputValues, inputKey);\n  if (!value) {\n    const keys = Object.keys(inputValues);\n    throw new Error(\"input values have \".concat(keys.length, \" keys, you must specify an input key or pass only 1 key as input\"));\n  }\n  return value;\n};\n/**\n * This function is used by memory classes to select the output value\n * to use for the memory. If there is only one output value, it is used.\n * If there are multiple output values, the outputKey must be specified.\n * If no outputKey is specified, an error is thrown.\n */\nexport const getOutputValue = (outputValues, outputKey) => {\n  const value = getValue(outputValues, outputKey);\n  if (!value) {\n    const keys = Object.keys(outputValues);\n    throw new Error(\"output values have \".concat(keys.length, \" keys, you must specify an output key or pass only 1 key as output\"));\n  }\n  return value;\n};\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages) {\n  let humanPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Human\";\n  let aiPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"AI\";\n  const string_messages = [];\n  for (const m of messages) {\n    let role;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"function\") {\n      role = \"Function\";\n    } else if (m._getType() === \"generic\") {\n      role = m.role;\n    } else {\n      throw new Error(\"Got unsupported message type: \".concat(m));\n    }\n    const nameStr = m.name ? \"\".concat(m.name, \", \") : \"\";\n    string_messages.push(\"\".concat(role, \": \").concat(nameStr).concat(m.content));\n  }\n  return string_messages.join(\"\\n\");\n}\nexport function getPromptInputKey(inputs, memoryVariables) {\n  const promptInputKeys = Object.keys(inputs).filter(key => !memoryVariables.includes(key) && key !== \"stop\");\n  if (promptInputKeys.length !== 1) {\n    throw new Error(\"One input key expected, but got \".concat(promptInputKeys.length));\n  }\n  return promptInputKeys[0];\n}","map":{"version":3,"names":["BaseMemory","getValue","values","key","undefined","keys","Object","length","getInputValue","inputValues","inputKey","value","Error","concat","getOutputValue","outputValues","outputKey","getBufferString","messages","humanPrefix","arguments","aiPrefix","string_messages","m","role","_getType","nameStr","name","push","content","join","getPromptInputKey","inputs","memoryVariables","promptInputKeys","filter","includes"],"sources":["C:/Users/zackb/OneDrive/Desktop/Bootcamp/best_project_ever/client/node_modules/langchain/dist/memory/base.js"],"sourcesContent":["export class BaseMemory {\n}\nconst getValue = (values, key) => {\n    if (key !== undefined) {\n        return values[key];\n    }\n    const keys = Object.keys(values);\n    if (keys.length === 1) {\n        return values[keys[0]];\n    }\n};\n/**\n * This function is used by memory classes to select the input value\n * to use for the memory. If there is only one input value, it is used.\n * If there are multiple input values, the inputKey must be specified.\n */\nexport const getInputValue = (inputValues, inputKey) => {\n    const value = getValue(inputValues, inputKey);\n    if (!value) {\n        const keys = Object.keys(inputValues);\n        throw new Error(`input values have ${keys.length} keys, you must specify an input key or pass only 1 key as input`);\n    }\n    return value;\n};\n/**\n * This function is used by memory classes to select the output value\n * to use for the memory. If there is only one output value, it is used.\n * If there are multiple output values, the outputKey must be specified.\n * If no outputKey is specified, an error is thrown.\n */\nexport const getOutputValue = (outputValues, outputKey) => {\n    const value = getValue(outputValues, outputKey);\n    if (!value) {\n        const keys = Object.keys(outputValues);\n        throw new Error(`output values have ${keys.length} keys, you must specify an output key or pass only 1 key as output`);\n    }\n    return value;\n};\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        string_messages.push(`${role}: ${nameStr}${m.content}`);\n    }\n    return string_messages.join(\"\\n\");\n}\nexport function getPromptInputKey(inputs, memoryVariables) {\n    const promptInputKeys = Object.keys(inputs).filter((key) => !memoryVariables.includes(key) && key !== \"stop\");\n    if (promptInputKeys.length !== 1) {\n        throw new Error(`One input key expected, but got ${promptInputKeys.length}`);\n    }\n    return promptInputKeys[0];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}