{"ast":null,"code":"import { BaseCallbackHandler } from \"../base.js\";\nexport class BaseTracer extends BaseCallbackHandler {\n  constructor(_fields) {\n    super(...arguments);\n    Object.defineProperty(this, \"runMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Map()\n    });\n  }\n  copy() {\n    return this;\n  }\n  _addChildRun(parentRun, childRun) {\n    parentRun.child_runs.push(childRun);\n  }\n  _startTrace(run) {\n    if (run.parent_run_id !== undefined) {\n      const parentRun = this.runMap.get(run.parent_run_id);\n      if (parentRun) {\n        this._addChildRun(parentRun, run);\n      }\n    }\n    this.runMap.set(run.id, run);\n  }\n  async _endTrace(run) {\n    const parentRun = run.parent_run_id !== undefined && this.runMap.get(run.parent_run_id);\n    if (parentRun) {\n      parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n    } else {\n      await this.persistRun(run);\n    }\n    this.runMap.delete(run.id);\n  }\n  _getExecutionOrder(parentRunId) {\n    const parentRun = parentRunId !== undefined && this.runMap.get(parentRunId);\n    // If a run has no parent then execution order is 1\n    if (!parentRun) {\n      return 1;\n    }\n    return parentRun.child_execution_order + 1;\n  }\n  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata) {\n    var _this$onLLMStart;\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata ? {\n      ...extraParams,\n      metadata\n    } : extraParams;\n    const run = {\n      id: runId,\n      name: llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [{\n        name: \"start\",\n        time: start_time\n      }],\n      inputs: {\n        prompts\n      },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams !== null && finalExtraParams !== void 0 ? finalExtraParams : {},\n      tags: tags || []\n    };\n    this._startTrace(run);\n    await ((_this$onLLMStart = this.onLLMStart) === null || _this$onLLMStart === void 0 ? void 0 : _this$onLLMStart.call(this, run));\n  }\n  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata) {\n    var _this$onLLMStart2;\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata ? {\n      ...extraParams,\n      metadata\n    } : extraParams;\n    const run = {\n      id: runId,\n      name: llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [{\n        name: \"start\",\n        time: start_time\n      }],\n      inputs: {\n        messages\n      },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams !== null && finalExtraParams !== void 0 ? finalExtraParams : {},\n      tags: tags || []\n    };\n    this._startTrace(run);\n    await ((_this$onLLMStart2 = this.onLLMStart) === null || _this$onLLMStart2 === void 0 ? void 0 : _this$onLLMStart2.call(this, run));\n  }\n  async handleLLMEnd(output, runId) {\n    var _this$onLLMEnd;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = output;\n    run.events.push({\n      name: \"end\",\n      time: run.end_time\n    });\n    await ((_this$onLLMEnd = this.onLLMEnd) === null || _this$onLLMEnd === void 0 ? void 0 : _this$onLLMEnd.call(this, run));\n    await this._endTrace(run);\n  }\n  async handleLLMError(error, runId) {\n    var _this$onLLMError;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = error.message;\n    run.events.push({\n      name: \"error\",\n      time: run.end_time\n    });\n    await ((_this$onLLMError = this.onLLMError) === null || _this$onLLMError === void 0 ? void 0 : _this$onLLMError.call(this, run));\n    await this._endTrace(run);\n  }\n  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType) {\n    var _this$onChainStart;\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run = {\n      id: runId,\n      name: chain.id[chain.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: chain,\n      events: [{\n        name: \"start\",\n        time: start_time\n      }],\n      inputs,\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: runType !== null && runType !== void 0 ? runType : \"chain\",\n      child_runs: [],\n      extra: metadata ? {\n        metadata\n      } : {},\n      tags: tags || []\n    };\n    this._startTrace(run);\n    await ((_this$onChainStart = this.onChainStart) === null || _this$onChainStart === void 0 ? void 0 : _this$onChainStart.call(this, run));\n  }\n  async handleChainEnd(outputs, runId) {\n    var _this$onChainEnd;\n    const run = this.runMap.get(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = outputs;\n    run.events.push({\n      name: \"end\",\n      time: run.end_time\n    });\n    await ((_this$onChainEnd = this.onChainEnd) === null || _this$onChainEnd === void 0 ? void 0 : _this$onChainEnd.call(this, run));\n    await this._endTrace(run);\n  }\n  async handleChainError(error, runId) {\n    var _this$onChainError;\n    const run = this.runMap.get(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = error.message;\n    run.events.push({\n      name: \"error\",\n      time: run.end_time\n    });\n    await ((_this$onChainError = this.onChainError) === null || _this$onChainError === void 0 ? void 0 : _this$onChainError.call(this, run));\n    await this._endTrace(run);\n  }\n  async handleToolStart(tool, input, runId, parentRunId, tags, metadata) {\n    var _this$onToolStart;\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run = {\n      id: runId,\n      name: tool.id[tool.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: tool,\n      events: [{\n        name: \"start\",\n        time: start_time\n      }],\n      inputs: {\n        input\n      },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"tool\",\n      child_runs: [],\n      extra: metadata ? {\n        metadata\n      } : {},\n      tags: tags || []\n    };\n    this._startTrace(run);\n    await ((_this$onToolStart = this.onToolStart) === null || _this$onToolStart === void 0 ? void 0 : _this$onToolStart.call(this, run));\n  }\n  async handleToolEnd(output, runId) {\n    var _this$onToolEnd;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = {\n      output\n    };\n    run.events.push({\n      name: \"end\",\n      time: run.end_time\n    });\n    await ((_this$onToolEnd = this.onToolEnd) === null || _this$onToolEnd === void 0 ? void 0 : _this$onToolEnd.call(this, run));\n    await this._endTrace(run);\n  }\n  async handleToolError(error, runId) {\n    var _this$onToolError;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = error.message;\n    run.events.push({\n      name: \"error\",\n      time: run.end_time\n    });\n    await ((_this$onToolError = this.onToolError) === null || _this$onToolError === void 0 ? void 0 : _this$onToolError.call(this, run));\n    await this._endTrace(run);\n  }\n  async handleAgentAction(action, runId) {\n    var _this$onAgentAction;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"chain\") {\n      return;\n    }\n    const agentRun = run;\n    agentRun.actions = agentRun.actions || [];\n    agentRun.actions.push(action);\n    agentRun.events.push({\n      name: \"agent_action\",\n      time: Date.now(),\n      kwargs: {\n        action\n      }\n    });\n    await ((_this$onAgentAction = this.onAgentAction) === null || _this$onAgentAction === void 0 ? void 0 : _this$onAgentAction.call(this, run));\n  }\n  async handleAgentEnd(action, runId) {\n    var _this$onAgentEnd;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"agent_end\",\n      time: Date.now(),\n      kwargs: {\n        action\n      }\n    });\n    await ((_this$onAgentEnd = this.onAgentEnd) === null || _this$onAgentEnd === void 0 ? void 0 : _this$onAgentEnd.call(this, run));\n  }\n  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata) {\n    var _this$onRetrieverStar;\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run = {\n      id: runId,\n      name: retriever.id[retriever.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: retriever,\n      events: [{\n        name: \"start\",\n        time: start_time\n      }],\n      inputs: {\n        query\n      },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"retriever\",\n      child_runs: [],\n      extra: metadata ? {\n        metadata\n      } : {},\n      tags: tags || []\n    };\n    this._startTrace(run);\n    await ((_this$onRetrieverStar = this.onRetrieverStart) === null || _this$onRetrieverStar === void 0 ? void 0 : _this$onRetrieverStar.call(this, run));\n  }\n  async handleRetrieverEnd(documents, runId) {\n    var _this$onRetrieverEnd;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = {\n      documents\n    };\n    run.events.push({\n      name: \"end\",\n      time: run.end_time\n    });\n    await ((_this$onRetrieverEnd = this.onRetrieverEnd) === null || _this$onRetrieverEnd === void 0 ? void 0 : _this$onRetrieverEnd.call(this, run));\n    await this._endTrace(run);\n  }\n  async handleRetrieverError(error, runId) {\n    var _this$onRetrieverErro;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = error.message;\n    run.events.push({\n      name: \"error\",\n      time: run.end_time\n    });\n    await ((_this$onRetrieverErro = this.onRetrieverError) === null || _this$onRetrieverErro === void 0 ? void 0 : _this$onRetrieverErro.call(this, run));\n    await this._endTrace(run);\n  }\n  async handleText(text, runId) {\n    var _this$onText;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"text\",\n      time: Date.now(),\n      kwargs: {\n        text\n      }\n    });\n    await ((_this$onText = this.onText) === null || _this$onText === void 0 ? void 0 : _this$onText.call(this, run));\n  }\n  async handleLLMNewToken(token, idx, runId) {\n    var _this$onLLMNewToken;\n    const run = this.runMap.get(runId);\n    if (!run || (run === null || run === void 0 ? void 0 : run.run_type) !== \"llm\") {\n      return;\n    }\n    run.events.push({\n      name: \"new_token\",\n      time: Date.now(),\n      kwargs: {\n        token,\n        idx\n      }\n    });\n    await ((_this$onLLMNewToken = this.onLLMNewToken) === null || _this$onLLMNewToken === void 0 ? void 0 : _this$onLLMNewToken.call(this, run));\n  }\n}","map":{"version":3,"names":["BaseCallbackHandler","BaseTracer","constructor","_fields","arguments","Object","defineProperty","enumerable","configurable","writable","value","Map","copy","_addChildRun","parentRun","childRun","child_runs","push","_startTrace","run","parent_run_id","undefined","runMap","get","set","id","_endTrace","child_execution_order","Math","max","persistRun","delete","_getExecutionOrder","parentRunId","handleLLMStart","llm","prompts","runId","extraParams","tags","metadata","_this$onLLMStart","execution_order","start_time","Date","now","finalExtraParams","name","length","serialized","events","time","inputs","run_type","extra","onLLMStart","call","handleChatModelStart","messages","_this$onLLMStart2","handleLLMEnd","output","_this$onLLMEnd","Error","end_time","outputs","onLLMEnd","handleLLMError","error","_this$onLLMError","message","onLLMError","handleChainStart","chain","runType","_this$onChainStart","onChainStart","handleChainEnd","_this$onChainEnd","onChainEnd","handleChainError","_this$onChainError","onChainError","handleToolStart","tool","input","_this$onToolStart","onToolStart","handleToolEnd","_this$onToolEnd","onToolEnd","handleToolError","_this$onToolError","onToolError","handleAgentAction","action","_this$onAgentAction","agentRun","actions","kwargs","onAgentAction","handleAgentEnd","_this$onAgentEnd","onAgentEnd","handleRetrieverStart","retriever","query","_this$onRetrieverStar","onRetrieverStart","handleRetrieverEnd","documents","_this$onRetrieverEnd","onRetrieverEnd","handleRetrieverError","_this$onRetrieverErro","onRetrieverError","handleText","text","_this$onText","onText","handleLLMNewToken","token","idx","_this$onLLMNewToken","onLLMNewToken"],"sources":["C:/Users/zackb/OneDrive/Desktop/Bootcamp/best_project_ever/client/node_modules/langchain/dist/callbacks/handlers/tracer.js"],"sourcesContent":["import { BaseCallbackHandler, } from \"../base.js\";\nexport class BaseTracer extends BaseCallbackHandler {\n    constructor(_fields) {\n        super(...arguments);\n        Object.defineProperty(this, \"runMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    copy() {\n        return this;\n    }\n    _addChildRun(parentRun, childRun) {\n        parentRun.child_runs.push(childRun);\n    }\n    _startTrace(run) {\n        if (run.parent_run_id !== undefined) {\n            const parentRun = this.runMap.get(run.parent_run_id);\n            if (parentRun) {\n                this._addChildRun(parentRun, run);\n            }\n        }\n        this.runMap.set(run.id, run);\n    }\n    async _endTrace(run) {\n        const parentRun = run.parent_run_id !== undefined && this.runMap.get(run.parent_run_id);\n        if (parentRun) {\n            parentRun.child_execution_order = Math.max(parentRun.child_execution_order, run.child_execution_order);\n        }\n        else {\n            await this.persistRun(run);\n        }\n        this.runMap.delete(run.id);\n    }\n    _getExecutionOrder(parentRunId) {\n        const parentRun = parentRunId !== undefined && this.runMap.get(parentRunId);\n        // If a run has no parent then execution order is 1\n        if (!parentRun) {\n            return 1;\n        }\n        return parentRun.child_execution_order + 1;\n    }\n    async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: start_time,\n                },\n            ],\n            inputs: { prompts },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        this._startTrace(run);\n        await this.onLLMStart?.(run);\n    }\n    async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const finalExtraParams = metadata\n            ? { ...extraParams, metadata }\n            : extraParams;\n        const run = {\n            id: runId,\n            name: llm.id[llm.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: llm,\n            events: [\n                {\n                    name: \"start\",\n                    time: start_time,\n                },\n            ],\n            inputs: { messages },\n            execution_order,\n            child_runs: [],\n            child_execution_order: execution_order,\n            run_type: \"llm\",\n            extra: finalExtraParams ?? {},\n            tags: tags || [],\n        };\n        this._startTrace(run);\n        await this.onLLMStart?.(run);\n    }\n    async handleLLMEnd(output, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = output;\n        run.events.push({\n            name: \"end\",\n            time: run.end_time,\n        });\n        await this.onLLMEnd?.(run);\n        await this._endTrace(run);\n    }\n    async handleLLMError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            throw new Error(\"No LLM run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = error.message;\n        run.events.push({\n            name: \"error\",\n            time: run.end_time,\n        });\n        await this.onLLMError?.(run);\n        await this._endTrace(run);\n    }\n    async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: chain.id[chain.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: chain,\n            events: [\n                {\n                    name: \"start\",\n                    time: start_time,\n                },\n            ],\n            inputs,\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: runType ?? \"chain\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        this._startTrace(run);\n        await this.onChainStart?.(run);\n    }\n    async handleChainEnd(outputs, runId) {\n        const run = this.runMap.get(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.outputs = outputs;\n        run.events.push({\n            name: \"end\",\n            time: run.end_time,\n        });\n        await this.onChainEnd?.(run);\n        await this._endTrace(run);\n    }\n    async handleChainError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run) {\n            throw new Error(\"No chain run to end.\");\n        }\n        run.end_time = Date.now();\n        run.error = error.message;\n        run.events.push({\n            name: \"error\",\n            time: run.end_time,\n        });\n        await this.onChainError?.(run);\n        await this._endTrace(run);\n    }\n    async handleToolStart(tool, input, runId, parentRunId, tags, metadata) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: tool.id[tool.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: tool,\n            events: [\n                {\n                    name: \"start\",\n                    time: start_time,\n                },\n            ],\n            inputs: { input },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"tool\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        this._startTrace(run);\n        await this.onToolStart?.(run);\n    }\n    async handleToolEnd(output, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { output };\n        run.events.push({\n            name: \"end\",\n            time: run.end_time,\n        });\n        await this.onToolEnd?.(run);\n        await this._endTrace(run);\n    }\n    async handleToolError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"tool\") {\n            throw new Error(\"No tool run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = error.message;\n        run.events.push({\n            name: \"error\",\n            time: run.end_time,\n        });\n        await this.onToolError?.(run);\n        await this._endTrace(run);\n    }\n    async handleAgentAction(action, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        const agentRun = run;\n        agentRun.actions = agentRun.actions || [];\n        agentRun.actions.push(action);\n        agentRun.events.push({\n            name: \"agent_action\",\n            time: Date.now(),\n            kwargs: { action },\n        });\n        await this.onAgentAction?.(run);\n    }\n    async handleAgentEnd(action, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"agent_end\",\n            time: Date.now(),\n            kwargs: { action },\n        });\n        await this.onAgentEnd?.(run);\n    }\n    async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata) {\n        const execution_order = this._getExecutionOrder(parentRunId);\n        const start_time = Date.now();\n        const run = {\n            id: runId,\n            name: retriever.id[retriever.id.length - 1],\n            parent_run_id: parentRunId,\n            start_time,\n            serialized: retriever,\n            events: [\n                {\n                    name: \"start\",\n                    time: start_time,\n                },\n            ],\n            inputs: { query },\n            execution_order,\n            child_execution_order: execution_order,\n            run_type: \"retriever\",\n            child_runs: [],\n            extra: metadata ? { metadata } : {},\n            tags: tags || [],\n        };\n        this._startTrace(run);\n        await this.onRetrieverStart?.(run);\n    }\n    async handleRetrieverEnd(documents, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.outputs = { documents };\n        run.events.push({\n            name: \"end\",\n            time: run.end_time,\n        });\n        await this.onRetrieverEnd?.(run);\n        await this._endTrace(run);\n    }\n    async handleRetrieverError(error, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"retriever\") {\n            throw new Error(\"No retriever run to end\");\n        }\n        run.end_time = Date.now();\n        run.error = error.message;\n        run.events.push({\n            name: \"error\",\n            time: run.end_time,\n        });\n        await this.onRetrieverError?.(run);\n        await this._endTrace(run);\n    }\n    async handleText(text, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"chain\") {\n            return;\n        }\n        run.events.push({\n            name: \"text\",\n            time: Date.now(),\n            kwargs: { text },\n        });\n        await this.onText?.(run);\n    }\n    async handleLLMNewToken(token, idx, runId) {\n        const run = this.runMap.get(runId);\n        if (!run || run?.run_type !== \"llm\") {\n            return;\n        }\n        run.events.push({\n            name: \"new_token\",\n            time: Date.now(),\n            kwargs: { token, idx },\n        });\n        await this.onLLMNewToken?.(run);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}