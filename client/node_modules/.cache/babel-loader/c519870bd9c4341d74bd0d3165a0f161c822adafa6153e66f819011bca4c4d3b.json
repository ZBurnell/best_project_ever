{"ast":null,"code":"import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n  const runtimeEnv = await getRuntimeEnvironment();\n  const envVars = getLangChainEnvVarsMetadata();\n  return runs.map(run => {\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n      ...extra,\n      runtime: {\n        ...runtimeEnv,\n        ...extra?.runtime\n      },\n      metadata: {\n        ...envVars,\n        ...(envVars.revision_id || run.revision_id ? {\n          revision_id: run.revision_id ?? envVars.revision_id\n        } : {}),\n        ...metadata\n      }\n    };\n    return run;\n  });\n}\nconst getTracingSamplingRate = () => {\n  const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n  if (samplingRateStr === undefined) {\n    return undefined;\n  }\n  const samplingRate = parseFloat(samplingRateStr);\n  if (samplingRate < 0 || samplingRate > 1) {\n    throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n  }\n  return samplingRate;\n};\n// utility functions\nconst isLocalhost = url => {\n  const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n  const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n  return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nconst raiseForStatus = async (response, operation) => {\n  // consume the response body to release the connection\n  // https://undici.nodejs.org/#/?id=garbage-collection\n  const body = await response.text();\n  if (!response.ok) {\n    throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n  }\n};\nasync function toArray(iterable) {\n  const result = [];\n  for await (const item of iterable) {\n    result.push(item);\n  }\n  return result;\n}\nfunction trimQuotes(str) {\n  if (str === undefined) {\n    return undefined;\n  }\n  return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n  if (!uuid.validate(str)) {\n    throw new Error(`Invalid UUID: ${str}`);\n  }\n}\nexport class Client {\n  constructor(config = {}) {\n    Object.defineProperty(this, \"apiKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"apiUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"webUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"caller\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"timeout_ms\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tenantId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"hideInputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"hideOutputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tracingSampleRate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"sampledPostUuids\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(this, \"autoBatchTracing\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"pendingAutoBatchedRuns\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 100\n    });\n    Object.defineProperty(this, \"autoBatchTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 250\n    });\n    Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 50\n    });\n    const defaultConfig = Client.getDefaultClientConfig();\n    this.tracingSampleRate = getTracingSamplingRate();\n    this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n    this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n    this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n    this.validateApiKeyIfHosted();\n    this.timeout_ms = config.timeout_ms ?? 12000;\n    this.caller = new AsyncCaller(config.callerOptions ?? {});\n    this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n    this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n    this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n    this.pendingAutoBatchedRunLimit = config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n  }\n  static getDefaultClientConfig() {\n    const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n    const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ?? \"https://api.smith.langchain.com\";\n    const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n    const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n    return {\n      apiUrl: apiUrl,\n      apiKey: apiKey,\n      webUrl: undefined,\n      hideInputs: hideInputs,\n      hideOutputs: hideOutputs\n    };\n  }\n  validateApiKeyIfHosted() {\n    const isLocal = isLocalhost(this.apiUrl);\n    if (!isLocal && !this.apiKey) {\n      throw new Error(\"API key must be provided when using hosted LangSmith API\");\n    }\n  }\n  getHostUrl() {\n    if (this.webUrl) {\n      return this.webUrl;\n    } else if (isLocalhost(this.apiUrl)) {\n      this.webUrl = \"http://localhost\";\n      return \"http://localhost\";\n    } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n      this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n      return this.webUrl;\n    } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n      this.webUrl = \"https://dev.smith.langchain.com\";\n      return \"https://dev.smith.langchain.com\";\n    } else {\n      this.webUrl = \"https://smith.langchain.com\";\n      return \"https://smith.langchain.com\";\n    }\n  }\n  get headers() {\n    const headers = {\n      \"User-Agent\": `langsmith-js/${__version__}`\n    };\n    if (this.apiKey) {\n      headers[\"x-api-key\"] = `${this.apiKey}`;\n    }\n    return headers;\n  }\n  processInputs(inputs) {\n    if (this.hideInputs) {\n      return {};\n    }\n    return inputs;\n  }\n  processOutputs(outputs) {\n    if (this.hideOutputs) {\n      return {};\n    }\n    return outputs;\n  }\n  prepareRunCreateOrUpdateInputs(run) {\n    const runParams = {\n      ...run\n    };\n    if (runParams.inputs !== undefined) {\n      runParams.inputs = this.processInputs(runParams.inputs);\n    }\n    if (runParams.outputs !== undefined) {\n      runParams.outputs = this.processOutputs(runParams.outputs);\n    }\n    return runParams;\n  }\n  async _getResponse(path, queryParams) {\n    const paramsString = queryParams?.toString() ?? \"\";\n    const url = `${this.apiUrl}${path}?${paramsString}`;\n    const response = await this.caller.call(fetch, url, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n    }\n    return response;\n  }\n  async _get(path, queryParams) {\n    const response = await this._getResponse(path, queryParams);\n    return response.json();\n  }\n  async *_getPaginated(path, queryParams = new URLSearchParams()) {\n    let offset = Number(queryParams.get(\"offset\")) || 0;\n    const limit = Number(queryParams.get(\"limit\")) || 100;\n    while (true) {\n      queryParams.set(\"offset\", String(offset));\n      queryParams.set(\"limit\", String(limit));\n      const url = `${this.apiUrl}${path}?${queryParams}`;\n      const response = await this.caller.call(fetch, url, {\n        method: \"GET\",\n        headers: this.headers,\n        signal: AbortSignal.timeout(this.timeout_ms)\n      });\n      if (!response.ok) {\n        throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n      }\n      const items = await response.json();\n      if (items.length === 0) {\n        break;\n      }\n      yield items;\n      if (items.length < limit) {\n        break;\n      }\n      offset += items.length;\n    }\n  }\n  async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n    const bodyParams = body ? {\n      ...body\n    } : {};\n    while (true) {\n      const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n        method: requestMethod,\n        headers: {\n          ...this.headers,\n          \"Content-Type\": \"application/json\"\n        },\n        signal: AbortSignal.timeout(this.timeout_ms),\n        body: JSON.stringify(bodyParams)\n      });\n      const responseBody = await response.json();\n      if (!responseBody) {\n        break;\n      }\n      if (!responseBody[dataKey]) {\n        break;\n      }\n      yield responseBody[dataKey];\n      const cursors = responseBody.cursors;\n      if (!cursors) {\n        break;\n      }\n      if (!cursors.next) {\n        break;\n      }\n      bodyParams.cursor = cursors.next;\n    }\n  }\n  _filterForSampling(runs, patch = false) {\n    if (this.tracingSampleRate === undefined) {\n      return runs;\n    }\n    if (patch) {\n      const sampled = [];\n      for (const run of runs) {\n        if (this.sampledPostUuids.has(run.id)) {\n          sampled.push(run);\n          this.sampledPostUuids.delete(run.id);\n        }\n      }\n      return sampled;\n    } else {\n      const sampled = [];\n      for (const run of runs) {\n        if (Math.random() < this.tracingSampleRate) {\n          sampled.push(run);\n          this.sampledPostUuids.add(run.id);\n        }\n      }\n      return sampled;\n    }\n  }\n  async triggerAutoBatchSend(runs) {\n    let batch = runs;\n    if (batch === undefined) {\n      batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n      this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n    }\n    await this.batchIngestRuns({\n      runCreates: batch.filter(item => item.action === \"create\").map(item => item.item),\n      runUpdates: batch.filter(item => item.action === \"update\").map(item => item.item)\n    });\n  }\n  appendRunCreateToAutoBatchQueue(item) {\n    const oldTimeout = this.autoBatchTimeout;\n    clearTimeout(this.autoBatchTimeout);\n    this.autoBatchTimeout = undefined;\n    this.pendingAutoBatchedRuns.push(item);\n    while (this.pendingAutoBatchedRuns.length >= this.pendingAutoBatchedRunLimit) {\n      const batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n      this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n      void this.triggerAutoBatchSend(batch);\n    }\n    if (this.pendingAutoBatchedRuns.length > 0) {\n      if (!oldTimeout) {\n        this.autoBatchTimeout = setTimeout(() => {\n          this.autoBatchTimeout = undefined;\n          void this.triggerAutoBatchSend();\n        }, this.autoBatchInitialDelayMs);\n      } else {\n        this.autoBatchTimeout = setTimeout(() => {\n          this.autoBatchTimeout = undefined;\n          void this.triggerAutoBatchSend();\n        }, this.autoBatchAggregationDelayMs);\n      }\n    }\n  }\n  async createRun(run) {\n    if (!this._filterForSampling([run]).length) {\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const session_name = run.project_name;\n    delete run.project_name;\n    const runCreate = this.prepareRunCreateOrUpdateInputs({\n      session_name,\n      ...run,\n      start_time: run.start_time ?? Date.now()\n    });\n    if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n      this.appendRunCreateToAutoBatchQueue({\n        action: \"create\",\n        item: runCreate\n      });\n      return;\n    }\n    const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([runCreate]);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(mergedRunCreateParams[0]),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create run\");\n  }\n  /**\n   * Batch ingest/upsert multiple runs in the Langsmith system.\n   * @param runs\n   */\n  async batchIngestRuns({\n    runCreates,\n    runUpdates\n  }) {\n    if (runCreates === undefined && runUpdates === undefined) {\n      return;\n    }\n    let preparedCreateParams = runCreates?.map(create => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n    let preparedUpdateParams = runUpdates?.map(update => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n    if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n      const createById = preparedCreateParams.reduce((params, run) => {\n        if (!run.id) {\n          return params;\n        }\n        params[run.id] = run;\n        return params;\n      }, {});\n      const standaloneUpdates = [];\n      for (const updateParam of preparedUpdateParams) {\n        if (updateParam.id !== undefined && createById[updateParam.id]) {\n          createById[updateParam.id] = {\n            ...createById[updateParam.id],\n            ...updateParam\n          };\n        } else {\n          standaloneUpdates.push(updateParam);\n        }\n      }\n      preparedCreateParams = Object.values(createById);\n      preparedUpdateParams = standaloneUpdates;\n    }\n    const body = {\n      post: this._filterForSampling(preparedCreateParams),\n      patch: this._filterForSampling(preparedUpdateParams, true)\n    };\n    if (!body.post.length && !body.patch.length) {\n      return;\n    }\n    preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\",\n      Accept: \"application/json\"\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/batch`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"batch create run\");\n  }\n  async updateRun(runId, run) {\n    assertUuid(runId);\n    if (run.inputs) {\n      run.inputs = this.processInputs(run.inputs);\n    }\n    if (run.outputs) {\n      run.outputs = this.processOutputs(run.outputs);\n    }\n    // TODO: Untangle types\n    const data = {\n      ...run,\n      id: runId\n    };\n    if (!this._filterForSampling([data], true).length) {\n      return;\n    }\n    if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n      this.appendRunCreateToAutoBatchQueue({\n        action: \"update\",\n        item: data\n      });\n      return;\n    }\n    const headers = {\n      ...this.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n      method: \"PATCH\",\n      headers,\n      body: JSON.stringify(run),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update run\");\n  }\n  async readRun(runId, {\n    loadChildRuns\n  } = {\n    loadChildRuns: false\n  }) {\n    assertUuid(runId);\n    let run = await this._get(`/runs/${runId}`);\n    if (loadChildRuns && run.child_run_ids) {\n      run = await this._loadChildRuns(run);\n    }\n    return run;\n  }\n  async getRunUrl({\n    runId,\n    run,\n    projectOpts\n  }) {\n    if (run !== undefined) {\n      let sessionId;\n      if (run.session_id) {\n        sessionId = run.session_id;\n      } else if (projectOpts?.projectName) {\n        sessionId = (await this.readProject({\n          projectName: projectOpts?.projectName\n        })).id;\n      } else if (projectOpts?.projectId) {\n        sessionId = projectOpts?.projectId;\n      } else {\n        const project = await this.readProject({\n          projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\"\n        });\n        sessionId = project.id;\n      }\n      const tenantId = await this._getTenantId();\n      return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n    } else if (runId !== undefined) {\n      const run_ = await this.readRun(runId);\n      if (!run_.app_path) {\n        throw new Error(`Run ${runId} has no app_path`);\n      }\n      const baseUrl = this.getHostUrl();\n      return `${baseUrl}${run_.app_path}`;\n    } else {\n      throw new Error(\"Must provide either runId or run\");\n    }\n  }\n  async _loadChildRuns(run) {\n    const childRuns = await toArray(this.listRuns({\n      id: run.child_run_ids\n    }));\n    const treemap = {};\n    const runs = {};\n    // TODO: make dotted order required when the migration finishes\n    childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n    for (const childRun of childRuns) {\n      if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n        throw new Error(`Child run ${childRun.id} has no parent`);\n      }\n      if (!(childRun.parent_run_id in treemap)) {\n        treemap[childRun.parent_run_id] = [];\n      }\n      treemap[childRun.parent_run_id].push(childRun);\n      runs[childRun.id] = childRun;\n    }\n    run.child_runs = treemap[run.id] || [];\n    for (const runId in treemap) {\n      if (runId !== run.id) {\n        runs[runId].child_runs = treemap[runId];\n      }\n    }\n    return run;\n  }\n  async *listRuns({\n    projectId,\n    projectName,\n    parentRunId,\n    referenceExampleId,\n    startTime,\n    executionOrder,\n    runType,\n    error,\n    id,\n    query,\n    filter,\n    limit\n  }) {\n    let projectId_ = projectId;\n    if (projectName) {\n      if (projectId) {\n        throw new Error(\"Only one of projectId or projectName may be given\");\n      }\n      projectId_ = (await this.readProject({\n        projectName\n      })).id;\n    }\n    const body = {\n      session: projectId_ ? [projectId_] : null,\n      run_type: runType,\n      reference_example: referenceExampleId,\n      query,\n      filter,\n      execution_order: executionOrder,\n      parent_run: parentRunId ? [parentRunId] : null,\n      start_time: startTime ? startTime.toISOString() : null,\n      error,\n      id,\n      limit\n    };\n    for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n      yield* runs;\n    }\n  }\n  async shareRun(runId, {\n    shareId\n  } = {}) {\n    const data = {\n      run_id: runId,\n      share_token: shareId || uuid.v4()\n    };\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      throw new Error(\"Invalid response from server\");\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async unshareRun(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare run\");\n  }\n  async readRunSharedLink(runId) {\n    assertUuid(runId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (result === null || !(\"share_token\" in result)) {\n      return undefined;\n    }\n    return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n  }\n  async listSharedRuns(shareToken, {\n    runIds\n  } = {}) {\n    const queryParams = new URLSearchParams({\n      share_token: shareToken\n    });\n    if (runIds !== undefined) {\n      for (const runId of runIds) {\n        queryParams.append(\"id\", runId);\n      }\n    }\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const runs = await response.json();\n    return runs;\n  }\n  async readDatasetSharedSchema(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n    return shareSchema;\n  }\n  async shareDataset(datasetId, datasetName) {\n    if (!datasetId && !datasetName) {\n      throw new Error(\"Either datasetId or datasetName must be given\");\n    }\n    if (!datasetId) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId = dataset.id;\n    }\n    const data = {\n      dataset_id: datasetId\n    };\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"PUT\",\n      headers: this.headers,\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const shareSchema = await response.json();\n    shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n    return shareSchema;\n  }\n  async unshareDataset(datasetId) {\n    assertUuid(datasetId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"unshare dataset\");\n  }\n  async readSharedDataset(shareToken) {\n    assertUuid(shareToken);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n      method: \"GET\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const dataset = await response.json();\n    return dataset;\n  }\n  async createProject({\n    projectName,\n    description = null,\n    metadata = null,\n    upsert = false,\n    projectExtra = null,\n    referenceDatasetId = null\n  }) {\n    const upsert_ = upsert ? `?upsert=true` : \"\";\n    const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n    const extra = projectExtra || {};\n    if (metadata) {\n      extra[\"metadata\"] = metadata;\n    }\n    const body = {\n      name: projectName,\n      extra,\n      description\n    };\n    if (referenceDatasetId !== null) {\n      body[\"reference_dataset_id\"] = referenceDatasetId;\n    }\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n    }\n    return result;\n  }\n  async updateProject(projectId, {\n    name = null,\n    description = null,\n    metadata = null,\n    projectExtra = null,\n    endTime = null\n  }) {\n    const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n    let extra = projectExtra;\n    if (metadata) {\n      extra = {\n        ...(extra || {}),\n        metadata\n      };\n    }\n    const body = {\n      name,\n      extra,\n      description,\n      end_time: endTime ? new Date(endTime).toISOString() : null\n    };\n    const response = await this.caller.call(fetch, endpoint, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    const result = await response.json();\n    if (!response.ok) {\n      throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n    }\n    return result;\n  }\n  async readProject({\n    projectId,\n    projectName,\n    includeStats\n  }) {\n    let path = \"/sessions\";\n    const params = new URLSearchParams();\n    if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId !== undefined) {\n      assertUuid(projectId);\n      path += `/${projectId}`;\n    } else if (projectName !== undefined) {\n      params.append(\"name\", projectName);\n    } else {\n      throw new Error(\"Must provide projectName or projectId\");\n    }\n    if (includeStats !== undefined) {\n      params.append(\"include_stats\", includeStats.toString());\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async _getTenantId() {\n    if (this._tenantId !== null) {\n      return this._tenantId;\n    }\n    const queryParams = new URLSearchParams({\n      limit: \"1\"\n    });\n    for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n      this._tenantId = projects[0].tenant_id;\n      return projects[0].tenant_id;\n    }\n    throw new Error(\"No projects found to resolve tenant.\");\n  }\n  async *listProjects({\n    projectIds,\n    name,\n    nameContains,\n    referenceDatasetId,\n    referenceDatasetName,\n    referenceFree\n  } = {}) {\n    const params = new URLSearchParams();\n    if (projectIds !== undefined) {\n      for (const projectId of projectIds) {\n        params.append(\"id\", projectId);\n      }\n    }\n    if (name !== undefined) {\n      params.append(\"name\", name);\n    }\n    if (nameContains !== undefined) {\n      params.append(\"name_contains\", nameContains);\n    }\n    if (referenceDatasetId !== undefined) {\n      params.append(\"reference_dataset\", referenceDatasetId);\n    } else if (referenceDatasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName: referenceDatasetName\n      });\n      params.append(\"reference_dataset\", dataset.id);\n    }\n    if (referenceFree !== undefined) {\n      params.append(\"reference_free\", referenceFree.toString());\n    }\n    for await (const projects of this._getPaginated(\"/sessions\", params)) {\n      yield* projects;\n    }\n  }\n  async deleteProject({\n    projectId,\n    projectName\n  }) {\n    let projectId_;\n    if (projectId === undefined && projectName === undefined) {\n      throw new Error(\"Must provide projectName or projectId\");\n    } else if (projectId !== undefined && projectName !== undefined) {\n      throw new Error(\"Must provide either projectName or projectId, not both\");\n    } else if (projectId === undefined) {\n      projectId_ = (await this.readProject({\n        projectName\n      })).id;\n    } else {\n      projectId_ = projectId;\n    }\n    assertUuid(projectId_);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n  }\n  async uploadCsv({\n    csvFile,\n    fileName,\n    inputKeys,\n    outputKeys,\n    description,\n    dataType,\n    name\n  }) {\n    const url = `${this.apiUrl}/datasets/upload`;\n    const formData = new FormData();\n    formData.append(\"file\", csvFile, fileName);\n    inputKeys.forEach(key => {\n      formData.append(\"input_keys\", key);\n    });\n    outputKeys.forEach(key => {\n      formData.append(\"output_keys\", key);\n    });\n    if (description) {\n      formData.append(\"description\", description);\n    }\n    if (dataType) {\n      formData.append(\"data_type\", dataType);\n    }\n    if (name) {\n      formData.append(\"name\", name);\n    }\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: this.headers,\n      body: formData,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(`Dataset ${fileName} already exists`);\n      }\n      throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createDataset(name, {\n    description,\n    dataType\n  } = {}) {\n    const body = {\n      name,\n      description\n    };\n    if (dataType) {\n      body.data_type = dataType;\n    }\n    const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(body),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      const result = await response.json();\n      if (result.detail && result.detail.includes(\"already exists\")) {\n        throw new Error(`Dataset ${name} already exists`);\n      }\n      throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async readDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    // limit to 1 result\n    const params = new URLSearchParams({\n      limit: \"1\"\n    });\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      assertUuid(datasetId);\n      path += `/${datasetId}`;\n    } else if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._get(path, params);\n    let result;\n    if (Array.isArray(response)) {\n      if (response.length === 0) {\n        throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n      }\n      result = response[0];\n    } else {\n      result = response;\n    }\n    return result;\n  }\n  async readDatasetOpenaiFinetuning({\n    datasetId,\n    datasetName\n  }) {\n    const path = \"/datasets\";\n    if (datasetId !== undefined) {\n      // do nothing\n    } else if (datasetName !== undefined) {\n      datasetId = (await this.readDataset({\n        datasetName\n      })).id;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n    const datasetText = await response.text();\n    const dataset = datasetText.trim().split(\"\\n\").map(line => JSON.parse(line));\n    return dataset;\n  }\n  async *listDatasets({\n    limit = 100,\n    offset = 0,\n    datasetIds,\n    datasetName,\n    datasetNameContains\n  } = {}) {\n    const path = \"/datasets\";\n    const params = new URLSearchParams({\n      limit: limit.toString(),\n      offset: offset.toString()\n    });\n    if (datasetIds !== undefined) {\n      for (const id_ of datasetIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    if (datasetName !== undefined) {\n      params.append(\"name\", datasetName);\n    }\n    if (datasetNameContains !== undefined) {\n      params.append(\"name_contains\", datasetNameContains);\n    }\n    for await (const datasets of this._getPaginated(path, params)) {\n      yield* datasets;\n    }\n  }\n  async deleteDataset({\n    datasetId,\n    datasetName\n  }) {\n    let path = \"/datasets\";\n    let datasetId_ = datasetId;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    if (datasetId_ !== undefined) {\n      assertUuid(datasetId_);\n      path += `/${datasetId_}`;\n    } else {\n      throw new Error(\"Must provide datasetName or datasetId\");\n    }\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async createExample(inputs, outputs, {\n    datasetId,\n    datasetName,\n    createdAt,\n    exampleId\n  }) {\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const createdAt_ = createdAt || new Date();\n    const data = {\n      dataset_id: datasetId_,\n      inputs,\n      outputs,\n      created_at: createdAt_?.toISOString(),\n      id: exampleId\n    };\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createExamples(props) {\n    const {\n      inputs,\n      outputs,\n      sourceRunIds,\n      exampleIds,\n      datasetId,\n      datasetName\n    } = props;\n    let datasetId_ = datasetId;\n    if (datasetId_ === undefined && datasetName === undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId\");\n    } else if (datasetId_ !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId_ === undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    }\n    const formattedExamples = inputs.map((input, idx) => {\n      return {\n        dataset_id: datasetId_,\n        inputs: input,\n        outputs: outputs ? outputs[idx] : undefined,\n        id: exampleIds ? exampleIds[idx] : undefined,\n        source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined\n      };\n    });\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(formattedExamples),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async createLLMExample(input, generation, options) {\n    return this.createExample({\n      input\n    }, {\n      output: generation\n    }, options);\n  }\n  async createChatExample(input, generations, options) {\n    const finalInput = input.map(message => {\n      if (isLangChainMessage(message)) {\n        return convertLangChainMessageToExample(message);\n      }\n      return message;\n    });\n    const finalOutput = isLangChainMessage(generations) ? convertLangChainMessageToExample(generations) : generations;\n    return this.createExample({\n      input: finalInput\n    }, {\n      output: finalOutput\n    }, options);\n  }\n  async readExample(exampleId) {\n    assertUuid(exampleId);\n    const path = `/examples/${exampleId}`;\n    return await this._get(path);\n  }\n  async *listExamples({\n    datasetId,\n    datasetName,\n    exampleIds\n  } = {}) {\n    let datasetId_;\n    if (datasetId !== undefined && datasetName !== undefined) {\n      throw new Error(\"Must provide either datasetName or datasetId, not both\");\n    } else if (datasetId !== undefined) {\n      datasetId_ = datasetId;\n    } else if (datasetName !== undefined) {\n      const dataset = await this.readDataset({\n        datasetName\n      });\n      datasetId_ = dataset.id;\n    } else {\n      throw new Error(\"Must provide a datasetName or datasetId\");\n    }\n    const params = new URLSearchParams({\n      dataset: datasetId_\n    });\n    if (exampleIds !== undefined) {\n      for (const id_ of exampleIds) {\n        params.append(\"id\", id_);\n      }\n    }\n    for await (const examples of this._getPaginated(\"/examples\", params)) {\n      yield* examples;\n    }\n  }\n  async deleteExample(exampleId) {\n    assertUuid(exampleId);\n    const path = `/examples/${exampleId}`;\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async updateExample(exampleId, update) {\n    assertUuid(exampleId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(update),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n    }\n    const result = await response.json();\n    return result;\n  }\n  async evaluateRun(run, evaluator, {\n    sourceInfo,\n    loadChildRuns,\n    referenceExample\n  } = {\n    loadChildRuns: false\n  }) {\n    let run_;\n    if (typeof run === \"string\") {\n      run_ = await this.readRun(run, {\n        loadChildRuns\n      });\n    } else if (typeof run === \"object\" && \"id\" in run) {\n      run_ = run;\n    } else {\n      throw new Error(`Invalid run type: ${typeof run}`);\n    }\n    if (run_.reference_example_id !== null && run_.reference_example_id !== undefined) {\n      referenceExample = await this.readExample(run_.reference_example_id);\n    }\n    const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n    let sourceInfo_ = sourceInfo ?? {};\n    if (feedbackResult.evaluatorInfo) {\n      sourceInfo_ = {\n        ...sourceInfo_,\n        ...feedbackResult.evaluatorInfo\n      };\n    }\n    const runId = feedbackResult.targetRunId ?? run_.id;\n    return await this.createFeedback(runId, feedbackResult.key, {\n      score: feedbackResult?.score,\n      value: feedbackResult?.value,\n      comment: feedbackResult?.comment,\n      correction: feedbackResult?.correction,\n      sourceInfo: sourceInfo_,\n      feedbackSourceType: \"model\",\n      sourceRunId: feedbackResult?.sourceRunId\n    });\n  }\n  async createFeedback(runId, key, {\n    score,\n    value,\n    correction,\n    comment,\n    sourceInfo,\n    feedbackSourceType = \"api\",\n    sourceRunId,\n    feedbackId,\n    eager = false\n  }) {\n    const feedback_source = {\n      type: feedbackSourceType ?? \"api\",\n      metadata: sourceInfo ?? {}\n    };\n    if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n      feedback_source.metadata[\"__run\"] = {\n        run_id: sourceRunId\n      };\n    }\n    if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n      assertUuid(feedback_source.metadata[\"__run\"].run_id);\n    }\n    const feedback = {\n      id: feedbackId ?? uuid.v4(),\n      run_id: runId,\n      key,\n      score,\n      value,\n      correction,\n      comment,\n      feedback_source: feedback_source\n    };\n    const url = `${this.apiUrl}/feedback` + (eager ? \"/eager\" : \"\");\n    const response = await this.caller.call(fetch, url, {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedback),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"create feedback\");\n    return feedback;\n  }\n  async updateFeedback(feedbackId, {\n    score,\n    value,\n    correction,\n    comment\n  }) {\n    const feedbackUpdate = {};\n    if (score !== undefined && score !== null) {\n      feedbackUpdate[\"score\"] = score;\n    }\n    if (value !== undefined && value !== null) {\n      feedbackUpdate[\"value\"] = value;\n    }\n    if (correction !== undefined && correction !== null) {\n      feedbackUpdate[\"correction\"] = correction;\n    }\n    if (comment !== undefined && comment !== null) {\n      feedbackUpdate[\"comment\"] = comment;\n    }\n    assertUuid(feedbackId);\n    const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n      method: \"PATCH\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(feedbackUpdate),\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    await raiseForStatus(response, \"update feedback\");\n  }\n  async readFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = `/feedback/${feedbackId}`;\n    const response = await this._get(path);\n    return response;\n  }\n  async deleteFeedback(feedbackId) {\n    assertUuid(feedbackId);\n    const path = `/feedback/${feedbackId}`;\n    const response = await this.caller.call(fetch, this.apiUrl + path, {\n      method: \"DELETE\",\n      headers: this.headers,\n      signal: AbortSignal.timeout(this.timeout_ms)\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n    }\n    await response.json();\n  }\n  async *listFeedback({\n    runIds,\n    feedbackKeys,\n    feedbackSourceTypes\n  } = {}) {\n    const queryParams = new URLSearchParams();\n    if (runIds) {\n      queryParams.append(\"run\", runIds.join(\",\"));\n    }\n    if (feedbackKeys) {\n      for (const key of feedbackKeys) {\n        queryParams.append(\"key\", key);\n      }\n    }\n    if (feedbackSourceTypes) {\n      for (const type of feedbackSourceTypes) {\n        queryParams.append(\"source\", type);\n      }\n    }\n    for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n      yield* feedbacks;\n    }\n  }\n}","map":{"version":3,"names":["uuid","AsyncCaller","convertLangChainMessageToExample","isLangChainMessage","getEnvironmentVariable","getLangChainEnvVarsMetadata","getRuntimeEnvironment","__version__","mergeRuntimeEnvIntoRunCreates","runs","runtimeEnv","envVars","map","run","extra","metadata","runtime","revision_id","getTracingSamplingRate","samplingRateStr","undefined","samplingRate","parseFloat","Error","isLocalhost","url","strippedUrl","replace","hostname","split","raiseForStatus","response","operation","body","text","ok","status","statusText","toArray","iterable","result","item","push","trimQuotes","str","trim","assertUuid","validate","Client","constructor","config","Object","defineProperty","enumerable","configurable","writable","value","Set","defaultConfig","getDefaultClientConfig","tracingSampleRate","apiUrl","apiKey","webUrl","validateApiKeyIfHosted","timeout_ms","caller","callerOptions","hideInputs","hideOutputs","autoBatchTracing","pendingAutoBatchedRunLimit","isLocal","getHostUrl","includes","endsWith","headers","processInputs","inputs","processOutputs","outputs","prepareRunCreateOrUpdateInputs","runParams","_getResponse","path","queryParams","paramsString","toString","call","fetch","method","signal","AbortSignal","timeout","_get","json","_getPaginated","URLSearchParams","offset","Number","get","limit","set","String","items","length","_getCursorPaginatedList","requestMethod","dataKey","bodyParams","JSON","stringify","responseBody","cursors","next","cursor","_filterForSampling","patch","sampled","sampledPostUuids","has","id","delete","Math","random","add","triggerAutoBatchSend","batch","pendingAutoBatchedRuns","slice","batchIngestRuns","runCreates","filter","action","runUpdates","appendRunCreateToAutoBatchQueue","oldTimeout","autoBatchTimeout","clearTimeout","setTimeout","autoBatchInitialDelayMs","autoBatchAggregationDelayMs","createRun","session_name","project_name","runCreate","start_time","Date","now","trace_id","dotted_order","mergedRunCreateParams","preparedCreateParams","create","preparedUpdateParams","update","createById","reduce","params","standaloneUpdates","updateParam","values","post","Accept","updateRun","runId","data","readRun","loadChildRuns","child_run_ids","_loadChildRuns","getRunUrl","projectOpts","sessionId","session_id","projectName","readProject","projectId","project","tenantId","_getTenantId","run_","app_path","baseUrl","childRuns","listRuns","treemap","sort","a","b","localeCompare","childRun","parent_run_id","child_runs","parentRunId","referenceExampleId","startTime","executionOrder","runType","error","query","projectId_","session","run_type","reference_example","execution_order","parent_run","toISOString","shareRun","shareId","run_id","share_token","v4","unshareRun","readRunSharedLink","listSharedRuns","shareToken","runIds","append","readDatasetSharedSchema","datasetId","datasetName","dataset","readDataset","shareSchema","shareDataset","dataset_id","unshareDataset","readSharedDataset","createProject","description","upsert","projectExtra","referenceDatasetId","upsert_","endpoint","name","updateProject","endTime","end_time","includeStats","Array","isArray","_tenantId","projects","tenant_id","listProjects","projectIds","nameContains","referenceDatasetName","referenceFree","deleteProject","uploadCsv","csvFile","fileName","inputKeys","outputKeys","dataType","formData","FormData","forEach","key","detail","createDataset","data_type","readDatasetOpenaiFinetuning","datasetText","line","parse","listDatasets","datasetIds","datasetNameContains","id_","datasets","deleteDataset","datasetId_","createExample","createdAt","exampleId","createdAt_","created_at","createExamples","props","sourceRunIds","exampleIds","formattedExamples","input","idx","source_run_id","createLLMExample","generation","options","output","createChatExample","generations","finalInput","message","finalOutput","readExample","listExamples","examples","deleteExample","updateExample","evaluateRun","evaluator","sourceInfo","referenceExample","reference_example_id","feedbackResult","sourceInfo_","evaluatorInfo","targetRunId","createFeedback","score","comment","correction","feedbackSourceType","sourceRunId","feedbackId","eager","feedback_source","type","feedback","updateFeedback","feedbackUpdate","readFeedback","deleteFeedback","listFeedback","feedbackKeys","feedbackSourceTypes","join","feedbacks"],"sources":["C:/Users/zackb/OneDrive/Desktop/Bootcamp/best_project_ever/client/node_modules/langsmith/dist/client.js"],"sourcesContent":["import * as uuid from \"uuid\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage, } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangChainEnvVarsMetadata, getRuntimeEnvironment, } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nasync function mergeRuntimeEnvIntoRunCreates(runs) {\n    const runtimeEnv = await getRuntimeEnvironment();\n    const envVars = getLangChainEnvVarsMetadata();\n    return runs.map((run) => {\n        const extra = run.extra ?? {};\n        const metadata = extra.metadata;\n        run.extra = {\n            ...extra,\n            runtime: {\n                ...runtimeEnv,\n                ...extra?.runtime,\n            },\n            metadata: {\n                ...envVars,\n                ...(envVars.revision_id || run.revision_id\n                    ? { revision_id: run.revision_id ?? envVars.revision_id }\n                    : {}),\n                ...metadata,\n            },\n        };\n        return run;\n    });\n}\nconst getTracingSamplingRate = () => {\n    const samplingRateStr = getEnvironmentVariable(\"LANGCHAIN_TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGCHAIN_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nconst raiseForStatus = async (response, operation) => {\n    // consume the response body to release the connection\n    // https://undici.nodejs.org/#/?id=garbage-collection\n    const body = await response.text();\n    if (!response.ok) {\n        throw new Error(`Failed to ${operation}: ${response.status} ${response.statusText} ${body}`);\n    }\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nfunction assertUuid(str) {\n    if (!uuid.validate(str)) {\n        throw new Error(`Invalid UUID: ${str}`);\n    }\n}\nexport class Client {\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"sampledPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRuns\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"pendingAutoBatchedRunLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 100\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchInitialDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 50\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate();\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        this.validateApiKeyIfHosted();\n        this.timeout_ms = config.timeout_ms ?? 12000;\n        this.caller = new AsyncCaller(config.callerOptions ?? {});\n        this.hideInputs = config.hideInputs ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.pendingAutoBatchedRunLimit =\n            config.pendingAutoBatchedRunLimit ?? this.pendingAutoBatchedRunLimit;\n    }\n    static getDefaultClientConfig() {\n        const apiKey = getEnvironmentVariable(\"LANGCHAIN_API_KEY\");\n        const apiUrl = getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ??\n            \"https://api.smith.langchain.com\";\n        const hideInputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_INPUTS\") === \"true\";\n        const hideOutputs = getEnvironmentVariable(\"LANGCHAIN_HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    validateApiKeyIfHosted() {\n        const isLocal = isLocalhost(this.apiUrl);\n        if (!isLocal && !this.apiKey) {\n            throw new Error(\"API key must be provided when using hosted LangSmith API\");\n        }\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost\";\n            return \"http://localhost\";\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return \"https://dev.smith.langchain.com\";\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return \"https://smith.langchain.com\";\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        return headers;\n    }\n    processInputs(inputs) {\n        if (this.hideInputs) {\n            return {};\n        }\n        return inputs;\n    }\n    processOutputs(outputs) {\n        if (this.hideOutputs) {\n            return {};\n        }\n        return outputs;\n    }\n    prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(fetch, url, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams()) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(fetch, url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n            });\n            if (!response.ok) {\n                throw new Error(`Failed to fetch ${path}: ${response.status} ${response.statusText}`);\n            }\n            const items = await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const response = await this.caller.call(fetch, `${this.apiUrl}${path}`, {\n                method: requestMethod,\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                body: JSON.stringify(bodyParams),\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (this.sampledPostUuids.has(run.id)) {\n                    sampled.push(run);\n                    this.sampledPostUuids.delete(run.id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            const sampled = [];\n            for (const run of runs) {\n                if (Math.random() < this.tracingSampleRate) {\n                    sampled.push(run);\n                    this.sampledPostUuids.add(run.id);\n                }\n            }\n            return sampled;\n        }\n    }\n    async triggerAutoBatchSend(runs) {\n        let batch = runs;\n        if (batch === undefined) {\n            batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n            this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n        }\n        await this.batchIngestRuns({\n            runCreates: batch\n                .filter((item) => item.action === \"create\")\n                .map((item) => item.item),\n            runUpdates: batch\n                .filter((item) => item.action === \"update\")\n                .map((item) => item.item),\n        });\n    }\n    appendRunCreateToAutoBatchQueue(item) {\n        const oldTimeout = this.autoBatchTimeout;\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        this.pendingAutoBatchedRuns.push(item);\n        while (this.pendingAutoBatchedRuns.length >= this.pendingAutoBatchedRunLimit) {\n            const batch = this.pendingAutoBatchedRuns.slice(0, this.pendingAutoBatchedRunLimit);\n            this.pendingAutoBatchedRuns = this.pendingAutoBatchedRuns.slice(this.pendingAutoBatchedRunLimit);\n            void this.triggerAutoBatchSend(batch);\n        }\n        if (this.pendingAutoBatchedRuns.length > 0) {\n            if (!oldTimeout) {\n                this.autoBatchTimeout = setTimeout(() => {\n                    this.autoBatchTimeout = undefined;\n                    void this.triggerAutoBatchSend();\n                }, this.autoBatchInitialDelayMs);\n            }\n            else {\n                this.autoBatchTimeout = setTimeout(() => {\n                    this.autoBatchTimeout = undefined;\n                    void this.triggerAutoBatchSend();\n                }, this.autoBatchAggregationDelayMs);\n            }\n        }\n    }\n    async createRun(run) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            this.appendRunCreateToAutoBatchQueue({\n                action: \"create\",\n                item: runCreate,\n            });\n            return;\n        }\n        const mergedRunCreateParams = await mergeRuntimeEnvIntoRunCreates([\n            runCreate,\n        ]);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(mergedRunCreateParams[0]),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create run\");\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? [];\n        let preparedUpdateParams = runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? [];\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const body = {\n            post: this._filterForSampling(preparedCreateParams),\n            patch: this._filterForSampling(preparedUpdateParams, true),\n        };\n        if (!body.post.length && !body.patch.length) {\n            return;\n        }\n        preparedCreateParams = await mergeRuntimeEnvIntoRunCreates(preparedCreateParams);\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/batch`, {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"batch create run\");\n    }\n    async updateRun(runId, run) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            this.appendRunCreateToAutoBatchQueue({ action: \"update\", item: data });\n            return;\n        }\n        const headers = { ...this.headers, \"Content-Type\": \"application/json\" };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}`, {\n            method: \"PATCH\",\n            headers,\n            body: JSON.stringify(run),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update run\");\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns && run.child_run_ids) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: getEnvironmentVariable(\"LANGCHAIN_PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({ id: run.child_run_ids }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (!(childRun.parent_run_id in treemap)) {\n                treemap[childRun.parent_run_id] = [];\n            }\n            treemap[childRun.parent_run_id].push(childRun);\n            runs[childRun.id] = childRun;\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    async *listRuns({ projectId, projectName, parentRunId, referenceExampleId, startTime, executionOrder, runType, error, id, query, filter, limit, }) {\n        let projectId_ = projectId;\n        if (projectName) {\n            if (projectId) {\n                throw new Error(\"Only one of projectId or projectName may be given\");\n            }\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        const body = {\n            session: projectId_ ? [projectId_] : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            execution_order: executionOrder,\n            parent_run: parentRunId ? [parentRunId] : null,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n        };\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            yield* runs;\n        }\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid.v4(),\n        };\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare run\");\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/runs/${runId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"PUT\",\n            headers: this.headers,\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets/${datasetId}/share`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"unshare dataset\");\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/public/${shareToken}/datasets`, {\n            method: \"GET\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to create session ${projectName}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = {\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        };\n        const response = await this.caller.call(fetch, endpoint, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            throw new Error(`Failed to update project ${projectId}: ${response.status} ${response.statusText}`);\n        }\n        return result;\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, referenceFree, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/sessions/${projectId_}`, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, `delete session ${projectId_} (${projectName})`);\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: this.headers,\n            body: formData,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${fileName} already exists`);\n            }\n            throw new Error(`Failed to upload CSV: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, } = {}) {\n        const body = {\n            name,\n            description,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        const response = await this.caller.call(fetch, `${this.apiUrl}/datasets`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(body),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            const result = await response.json();\n            if (result.detail && result.detail.includes(\"already exists\")) {\n                throw new Error(`Dataset ${name} already exists`);\n            }\n            throw new Error(`Failed to create dataset ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async createExample(inputs, outputs, { datasetId, datasetName, createdAt, exampleId }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = createdAt || new Date();\n        const data = {\n            dataset_id: datasetId_,\n            inputs,\n            outputs,\n            created_at: createdAt_?.toISOString(),\n            id: exampleId,\n        };\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(data),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create example: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createExamples(props) {\n        const { inputs, outputs, sourceRunIds, exampleIds, datasetId, datasetName, } = props;\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs ? outputs[idx] : undefined,\n                id: exampleIds ? exampleIds[idx] : undefined,\n                source_run_id: sourceRunIds ? sourceRunIds[idx] : undefined,\n            };\n        });\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/bulk`, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(formattedExamples),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to create examples: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if (isLangChainMessage(message)) {\n                return convertLangChainMessageToExample(message);\n            }\n            return message;\n        });\n        const finalOutput = isLangChainMessage(generations)\n            ? convertLangChainMessageToExample(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        return await this._get(path);\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        for await (const examples of this._getPaginated(\"/examples\", params)) {\n            yield* examples;\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async updateExample(exampleId, update) {\n        assertUuid(exampleId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/examples/${exampleId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(update),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to update example ${exampleId}: ${response.status} ${response.statusText}`);\n        }\n        const result = await response.json();\n        return result;\n    }\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        let sourceInfo_ = sourceInfo ?? {};\n        if (feedbackResult.evaluatorInfo) {\n            sourceInfo_ = { ...sourceInfo_, ...feedbackResult.evaluatorInfo };\n        }\n        const runId = feedbackResult.targetRunId ?? run_.id;\n        return await this.createFeedback(runId, feedbackResult.key, {\n            score: feedbackResult?.score,\n            value: feedbackResult?.value,\n            comment: feedbackResult?.comment,\n            correction: feedbackResult?.correction,\n            sourceInfo: sourceInfo_,\n            feedbackSourceType: \"model\",\n            sourceRunId: feedbackResult?.sourceRunId,\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, eager = false, }) {\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid.v4(),\n            run_id: runId,\n            key,\n            score,\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n        };\n        const url = `${this.apiUrl}/feedback` + (eager ? \"/eager\" : \"\");\n        const response = await this.caller.call(fetch, url, {\n            method: \"POST\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedback),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"create feedback\");\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = score;\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const response = await this.caller.call(fetch, `${this.apiUrl}/feedback/${feedbackId}`, {\n            method: \"PATCH\",\n            headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(feedbackUpdate),\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        await raiseForStatus(response, \"update feedback\");\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this.caller.call(fetch, this.apiUrl + path, {\n            method: \"DELETE\",\n            headers: this.headers,\n            signal: AbortSignal.timeout(this.timeout_ms),\n        });\n        if (!response.ok) {\n            throw new Error(`Failed to delete ${path}: ${response.status} ${response.statusText}`);\n        }\n        await response.json();\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            queryParams.append(\"run\", runIds.join(\",\"));\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}